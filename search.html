<!DOCTYPE html>
<html lang="ru">

<head>

	<meta charset="utf-8">
	<base href="/">

	<title>Frontendly - Cтатьи и новости из мира Front-end</title>
	<meta name="description" content="Cтатьи и новости из мира Front-end и программирования в целом">

	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	
	<!-- Template Basic Images Start -->
	<meta property="og:image" content="img/frontendly.jpg">
	<link rel="icon" href="img/favicon/favicon.ico">
	<link rel="apple-touch-icon" sizes="180x180" href="img/favicon/apple-touch-icon-180x180.png">
	<!-- Template Basic Images End -->
	
	<!-- Custom Browsers Color Start -->
	<meta name="theme-color" content="#202225">
	<!-- Custom Browsers Color End -->

	<link rel="stylesheet" href="css/main.min.css">

</head>

<body class="ishome">



<header class="top-line">

	<a href="/" class="logo logo-litera">Frontendly</a>

	<div class="search-wrap">
		<div class="search" title="Поиск по сайту..."><div class="fa fa-search"></div></div>
		<div class="search-field">
			<form action="/search.html" id="cse-search-box" method="get">
				<input type="hidden" name="cx" value="partner-pub-xxx:xxx" />
				<input type="hidden" name="cof" value="FORID:10" />
				<input type="hidden" name="ie" value="UTF-8" />
				<input type="text" id="search-box" name="query" placeholder="Поиск по сайту..." />
			</form>
		</div>
	</div>

	<div class="mobile-menu-button"><i class="fa fa-bars"></i> Меню</div>
	<nav class="main-menu top-menu">
<ul>
	<li><a href="blog/javascript/">JavaScript</a></li>
	<li><a href="blog/html-css/">Html&Css</a></li>
	<li><a href="blog/design/">Дизайн</a></li>
	<li><a href="blog/it-news/">Новости</a></li>
	<li><a href="blog/other/">Другое</a></li>
	<li><a href="projects/">Проекты</a></li>
</ul>
	</nav>
	<div class="preloader"><div class="pulse"></div></div>
</header>

	<div class="article-content">
		<div class="container-fluid">
			<div class="row">

				<div class="col-md-8">

					<article class="main-article">

						<h2>Результаты поиска:</h2>

						<div class="article-body">

							<div id="cse-search-results"></div>
							<!--<script type="text/javascript">-->
								<!--var googleSearchIframeName = "cse-search-results";-->
								<!--var googleSearchFormName = "cse-search-box";-->
								<!--var googleSearchFrameWidth = 800;-->
								<!--var googleSearchDomain = "www.google.ru";-->
								<!--var googleSearchPath = "/cse";-->
							<!--</script>-->
							<!--<script type="text/javascript" src="https://www.google.com/afsonline/show_afs_search.js"></script>-->
							<div class="search">
								<ul id="search-results"></ul>

<script>
    window.store = {
    
    "blog-html-css-2018-05-25-vvedenie-v-css-grid-html": {
        "title": "Введение в CSS Grid",
            "author": "",
            "category": "",
            "content": "    С помощью CSS Grid веб станет гораздо более красивым, чем то, к чему мы привыкли....CSS Grid — первая реальная система построения сеток. Она предназначена для размещения контента как в столбцах, так и в строках, и, наконец, дает разработчикам почти неограниченный контроль над элементами на экране. Это означает, что мы можем, наконец, избавиться от многолетних хаков и обходных решений для размещения элементов на веб-странице — в конечном счете это означает, что сложные макеты теперь не только возможно реализовывать, но и легко поддерживать.Хорошо, но как работает CSS Grid? Есть много сложных и ужасно подробных руководств, но я думаю, что мы должны начать с самых основ. То, что мы будем делать здесь, является относительно простой задачей размещения букв алфавита на странице.Для начала добавим разметку:&lt;div class='wrapper'&gt;    &lt;div class='letter'&gt;        A    &lt;/div&gt;    &lt;div class='letter'&gt;        B    &lt;/div&gt;&lt;/div&gt;Стилизуем эти буквы с помощью свойств font-size и color и центрируем в блоке с помощью свойств flexbox align-items и justify-content. И да, это правильно! CSS Grid не заменяет свойства flexbox, он дополняет то, что они уже делают. Мы можем использовать многие из этих свойств в сочетании с CSS Grid. Но сейчас вернемся к демонстрации:В примере выше у нас есть два простых div’а, расположенных друг под другом, потому что они по умолчанию — display: block. Установим для родительского элемента display: grid:.wrapper {    display: grid;}Вы можете увидеть, что ничего не произошло. И вы будете правы! В отличие от display: inline-block; или display: inline; не совсем ясно, что происходит, когда мы устанавливаем свойство display в grid. Фактически, чтобы заставить нашу сетку что-то делать, нам сначала нужно задать ей определенное количество столбцов или строк. Выровняем буквы рядом друг с другом в два столбца:.wrapper {    display: grid;    grid-template-columns: 1fr 1fr;    grid-column-gap: 1px;    background-color: black;}See the Pen Type Specimen Grid Demo – 1 by Robin Rendle (@robinrendle) on CodePen.Давайте разберем эти новые строки кода. Сначала мы создаем два столбца нашей сетки с помощью grid-template-columns. Значение 1fr может показаться странным, если вы никогда его раньше не видели, но это валидная единица измерения в CSS, которая сообщает каждой колонке, что она будет занимать одну часть сетки. В нашем случае это означает, что сетка будет иметь два столбца равной ширины.See the Pen Type Specimen Grid Demo – 2 by Robin Rendle (@robinrendle) on CodePen.Ура! Оно работает. Видите небольшой зазор между буквами? Это цвет фона, выглядывающий из-под блоков, поскольку мы задали значение свойства grid-column-gap 1px. Обычно задается больший зазор, особенно, для текстовых блоков, но в нашем случае достаточно и одного пикселя.А что произойдет, если добавить две новые буквы в разметку? Как это изменит страницу?&lt;div class='wrapper'&gt;    &lt;div class='letter'&gt;        A    &lt;/div&gt;    &lt;div class='letter'&gt;        B    &lt;/div&gt;    &lt;div class='letter'&gt;        C    &lt;/div&gt;    &lt;div class='letter'&gt;        D    &lt;/div&gt;&lt;/div&gt;Ну, технически это не изменит сетку — мы уже сказали, что она будет иметь две колонки, поэтому новые буквы будут расположены под ними.See the Pen Type Specimen Grid Demo – 3 by Robin Rendle (@robinrendle) on CodePen.Странная вещь — почему нет зазора в 1px между буквами A и C или между B и D? Все правильно, свойство grid-column-gap устанавливает зазор только между столбцами. Чтобы исправить это, можно добавить свойство grid-row-gap:.wrapper {    grid-column-gap: 1px;    grid-row-gap: 1px;    /* прочие стили */    /* можно использовать сокращение ‘grid-gap’ */}Теперь наш пример выглядит та:See the Pen Type Specimen Grid Demo – 4 by Robin Rendle (@robinrendle) on CodePen.Мы создали нашу первую сетку. Но давайте просто изучим наши колонки немного подробнее. Что произойдет, если мы добавим другое значение в свойство grid-template-columns? Например:.wrapper {    grid-template-columns: 1fr 1fr 1fr;}Ну, добавится еще одна колонка, конечно же! Обратите внимание, как мы теперь можем четко видеть фон обертки, потому ничто не закрывает его:See the Pen Type Specimen Grid Demo – 5 by Robin Rendle (@robinrendle) on CodePen.Если мы изменим значение fr в свойстве grid-template-columns, это создаст так называемую асимметричную сетку. Предположим, что мы бы хотели, чтобы наш первый столбец занимал втрое больше места, чем два других столбца:.wrapper {    grid-template-columns: 3fr 1fr 1fr;}Столбцы A и D стали шире остальных столбцов, как и ожидалось:See the Pen Type Specimen Grid Demo – 6 by Robin Rendle (@robinrendle) on CodePen.Разве это не мощно? Больше не нужно беспокоиться об отрицательных отступах или идеальных значениях в процентах, чтобы выровнять колонки. Мы можем создавать суперсложные сетки без необходимости делать какие-либо математические вычисления, которые мы были вынуждены делать раньше. Теперь нам просто нужно добавить новое значение в свойство grid-template-columns и вуаля, новый столбец появляется как по волшебству!Но как насчет адаптивных сеток, спросите вы? Это действительно так же просто, как изменить свойство в медиа-запросе. Предположим, что мы хотим по умолчанию видеть 2 столбца, на экранах больше 500 пикселей мы хотим 3 столбца, и, наконец, на больших экранах мы разместить все содержимое в 4 столбца. Все, что нам нужно написать, это:.wrapper {    display: grid;    grid-template-columns: 1fr 1fr;    @media screen and (min-width: 500px) {        grid-template-columns: 1fr 1fr 1fr;}    @media screen and (min-width: 800px) {        grid-template-columns: 1fr 1fr 1fr 1fr;    }}Откройте демо в отдельной вкладке и убедитесь, что адаптивная магия работает!Свойство grid-template-columns намного сложнее, чем показано здесь, но и это отличная отправная точка. Далее мы должны подробнее познакомиться с другим важным свойством в спецификации CSS Grid: grid-template-rows.Хорошо, давайте сделаем это. Ниже приведен небольшой фрагмент кода. С учетом того, что вы раньше не сталкивались с CSS Grid, попробуйте догадаться, что делает свойство grid-template-rows:.wrapper {    display: grid;    grid-template-columns: 3fr 1fr 1fr;    grid-template-rows: 1fr 3fr;}Это свойство устанавливает высоту строк и их взаимосвязь друг относительно друга. Если у нас есть две строки, как в нашем предыдущем демо, а последний блок установлен в 3fr, это означает, что высота второй строки всегда будет в три раза больше высоты первой:See the Pen Type Specimen Grid Demo – 8 by Robin Rendle (@robinrendle) on CodePen.Это может выглядеть довольно просто, но раньше мы не могли этого сделать. Нам приходилось писать хаки, такие как установка минимальной высоты для определенного элемента или изменение имени класса. Но мы никогда не могли задать отношения между строками; вот что делает CSS Grid таким мощным.Даже благодаря такому небольшому количеству знаний и нескольким новым свойствам мы можем создавать сказочно сложные макеты — асимметричные и адаптивные сетки — это еще не все.Весь код в примерах выше выглядит на первый взгляд очень странно. Но с ним теряют актуальность и гигантские CSS-фреймворки, и целый набор старых хаков. CSS Grid позволяет нам взглянуть на пространство внутри браузера совершенно по-новому.Нам придется изучить кучу новых свойств и полностью переосмыслить то, что мы знали раньше. Поэтому CSS Grid — это не только спецификация, а целая философия.",
        "url": "/blog/html-css/2018-05-25-vvedenie-v-css-grid.html"
    }
    ,
    
    "blog-javascript-2018-05-20-vvedenie-v-karrirovanie-v-javascript-html": {
        "title": "Введение в каррирование в JavaScript",
            "author": "",
            "category": "",
            "content": "    Каррирование или частичное применение это одна из техник функционального программирования, которая может показаться странной людям, знакомым с более традиционными способами написания JavaScript. Но при правильном применении каррирование действительно способно сделать ваш JavaScript более читаемым.Читаемость и гибкостьОдним из преимуществ функционального JavaScript является короткий и сжатый код, позволяющий использовать минимум строк с меньшим повторением. Иногда это достигается ценой читаемости — пока вы незнакомы с тем, как работает функциональное программирование, написанный таким образом код будет сложнее читать и понимать.Если вы сталкивались с термином каррирование ранее, но не знали, что он означает, то вы можете думать об этом как об экзотической и специфичной технике, о которой вам не нужно беспокоиться. Но на самом деле каррирование это очень простая концепция, решающая знакомые проблемы при работе с аргументами функции, открывая много гибких опций для разработчика.Что такое каррирование?Говоря кратко, каррирование это способ конструирования функций, позволяющий частичное применение аргументов функции. Это означает, что вы можете передать все аргументы, ожидаемые функцией и получить результат или передать часть этих аргументов и получить обратно функцию, ожидающую остальные аргументы. Все просто на самом деле.Чтобы дать вам понимание, как это должно работать, давайте создадим нашу первую каррированную функцию в JavaScript, используя знакомый синтаксис для построения нужной нам функциональности с использованием каррирования. В качестве примера представим функцию, приветствующую кого-нибудь по имени. Мы все знаем, как создать простую приветствующую функцию, принимающую имя и приветствие и выводящую в консоль приветствие с именем:var greet = function(greeting, name) {console.log(greeting + \", \" + name);};greet(\"Hello\", \"Heidi\"); //\"Hello, Heidi\"Эта функция для корректной работы ожидает в качестве аргументов имя и приветствие. Но мы можем переписать ее, используя вложенное каррирование так, что базовая функция будет требовать только приветствие и возвращать другую функцию, принимающую имя человека, которого мы хотим приветствовать.Наше первое карриvar greetCurried = function(greeting) {    return function(name) {        console.log(greeting + \", \" + name);    };};Это небольшое улучшение к способу написания функции позволит нам создать новую функцию для любого типа приветствия и передать этой новой функции имя человека, которого мы хотим приветствовать:var greetHello = greetCurried(\"Hello\");greetHello(\"Heidi\"); //\"Hello, Heidi\"greetHello(\"Eddie\"); //\"Hello, Eddie\"Мы также напрямую вызываем оригинальную каррированную функцию, просто передавая каждый из параметров в отдельных круглых скобках один за другим:greetCurried(\"Hi there\")(\"Howard\"); //\"Hi there, Howard\"Каррируем всеХорошая новость состоит в том, что изучив то, как можно модифицировать нашу традиционную функцию и используя этот подход для работы с аргументами, мы можем это делать с любым количеством аргументов.var greetDeeplyCurried = function(greeting) {    return function(separator) {        return function(emphasis) {            return function(name) {                console.log(greeting + separator + name + emphasis);            };        };    };};У нас та же самая гибкость при работе с четырьмя аргументами, что и ранее при работе с двумя. Не имеет значения, насколько глубоко вложение, мы можем создавать новые функции для поздравления любого количества людей всеми доступными способами:var greetAwkwardly = greetDeeplyCurried(\"Hello\")(\"...\")(\"?\");greetAwkwardly(\"Heidi\"); //\"Hello...Heidi?\"greetAwkwardly(\"Eddie\"); //\"Hello...Eddie?\"Чего же больше, мы можем передавать столько параметров, сколько хотим при создании вариантов новых функций, которые способны принимать соответствующее количество дополнительных параметров, каждый из которых передается в отдельных скобках:var sayHello = greetDeeplyCurried(\"Hello\")(\", \");sayHello(\".\")(\"Heidi\"); //\"Hello, Heidi.\"sayHello(\".\")(\"Eddie\"); //\"Hello, Eddie.\"И мы можем с легкостью задавать подчиненные вариации:var askHello = sayHello(\"?\");askHello(\"Heidi\"); //\"Hello, Heidi?\"askHello(\"Eddie\"); //\"Hello, Eddie?\"Каррирование традиционных функцийВы можете видеть, насколько мощный этот подход, особенно если вам надо создать много детализированных кастомных функций. Единственная проблема это синтаксис. При создании каррированных функций вам надо сохранять вложенность возвращаемых функций и вызывать их с помощью новых функций, требующих многочисленные наборы скобок, в каждом из которых содержится свой изолированный аргумент. Это может стать запутанным.Одним из путей решения этой проблемы является создание быстрой и грязной каррирующей функции, которая будет принимать имя существующей функции, написанной без всех вложенных возвращений. Каррирующая функция должна вытащить список аргументов для этой функции и использовать их для возврата каррированной версии оригинальной функции.var curryIt = function(uncurried) {    var parameters = Array.prototype.slice.call(arguments, 1);    return function() {        return uncurried.apply(this, parameters.concat(            Array.prototype.slice.call(arguments, 0)        ));    };};Чтобы использовать ее, мы передаем имя функции, принимающей любое количество аргументов вместе с теми аргументами, которые мы хотим предварительно заполнить. Назад мы получаем функцию, ожидающую оставшиеся аргументы:var greeter = function(greeting, separator, emphasis, name) {    console.log(greeting + separator + name + emphasis);};var greetHello = curryIt(greeter, \"Hello\", \", \", \".\");greetHello(\"Heidi\"); //\"Hello, Heidi.\"greetHello(\"Eddie\"); //\"Hello, Eddie.\"И так же, как и раньше, мы не ограничены в количестве аргументов, которые хотим использовать при построении производных функций из нашей оригинальной каррированной функции:var greetGoodbye = curryIt(greeter, \"Goodbye\", \", \");greetGoodbye(\".\", \"Joe\"); //\"Goodbye, Joe.\"Серьезное каррированиеНаша небольшая каррирующая функция не способна обработать все возможные ситуации типа отсутствующих или опциональных параметров, но она делает осмысленную работу, пока мы придерживаемся строгого синтаксиса при передаче аргументов.Некоторые функциональные библиотеки, такие как Ramda обладают более гибкими каррирующими функциями, которые могут разделять параметры, необходимые для функции и позволяют передавать их индивидуально или группами для создания каррированных версий. Если вы хотите активно использовать каррирование, то это, возможно, подойдет вам.Порядок аргументовПри каррирование функций очень важно учитывать порядок аргументов. Используя описанный подход вам нужно, чтобы заменяемый аргумент был последним среди аргументов, передаваемых в исходную функцию.Изначальный учет порядка аргументов облегчит планирование каррирования и применение его в работе. И учет порядка аргументов с точки зрения вероятности их изменения это хорошая привычка при проектировании любых функций.ЗаключениеКаррирование это крайне полезная техника в функциональном JavaScript. Она позволяет вам генерировать библиотеку небольших, легко конфигурируемых функций с последовательным поведением, которые быстро используются и могут быть легко поняты при чтении вашего кода. Добавление каррирования к вашей практике написания кода будет поощрять использование частично примененных функций, поможет избежать возможного повторение и улучшит ваши привычке по именованию и работе с аргументами функций.",
        "url": "/blog/javascript/2018-05-20-vvedenie-v-karrirovanie-v-javascript.html"
    }
    ,
    
    "blog-javascript-2018-05-19-myshlenie-v-stile-ramda-pervye-shagi-html": {
        "title": "Мышление в стиле Ramda - первые шаги",
            "author": "",
            "category": "",
            "content": "  Я нашёл Ramda прекрасно спроектированной библиотекой, которая предоставляет множество инструментов для чистого и элегантного функционального программирования в JavaScript.Если вы желаете поэкспериментировать с Ramda в процессе чтения этой серии статей, то на сайте Ramda имеется удобная браузерная  песочница для ваших экспериментов.ФункцииКак следует из названия, функциональное программирование имеет много общего с функциями. Для нашей ситуации, мы определим функцию как кусочек переиспользуемого кода, который вызывается с количеством аргументов, равным нулю и более, и возвращает результат.Это простая функция, написанная на JavaScript:function double(x) {  return x * 2}Вместе со стрелочными функциями из ES6, вы можете написать ту же самую функцию гораздо более кратко. Я упоминаю об этом сейчас, потому что мы будем использовать множество стрелочных функций по мере продвижения наших статей.const double = x =&gt; x * 2Некоторые языки идут дальше и предоставляют поддержку для функций как конструкций первого класса. Под «конструкциями первого класса» я подразумеваю, что функции могут использоваться таким же образом, как прочие значения. К примеру, вы можете:  ссылаться на них в константах и переменных  передавать их в качестве параметров в другие функции  возвращать их как результат от других функцийJavaScript — один из подобных языков, и мы будем использовать это преимущество.Чистые функцииПри написании функциональных программ, вы в конце концов приходите к пониманию важности работы с так называемыми «чистыми» функциями.Чистые функции — это функции, которые не имеют побочных эффектов. Они ничего не присваивают внешним переменным, они не уничтожают входные данные, не генерируют вывод, не читают и не пишут в базу данных, они не изменяют параметры, которые были им переданы, и так далее.Основная идея заключается в том, что если вы вызываете функцию с теми же параметрами снова и снова, то вы всегда будете получать один и тот же результат.Безусловно, вы можете делать различные дела с нечистыми функциями (и должны, если ваша программа делает что-то интересное), но для большей части кода вы желаете сохранить свои функции чистыми.НеизменяемостьДругая важная концепция в функциональном программировании — это «иммутабельность». Что это значит? «Иммутабельный» означает «неизменяемый».Когда я работаю c иммутабельностью, после первичной инициализации значения или объекта, я уже не изменяю их вновь. Это значит, что вы не изменяете элементы в массиве или свойства объектов.Если мне необходимо изменить что-то в массиве или объекте, — я возвращаю новую его копию с изменёнными значениями. В последующих постах мы поговорим об этом в подробностях.Иммутабельность идёт рука об руку с чистыми функциями. Поскольку чистые функции не имеют права создавать побочные эффекты, они не имеют права изменять внешние структуры данных. Они вынуждены работать с данными в иммутабельном стиле.С чего начать?Самый простой путь начать мыслить в функциональной парадигме — начать заменять циклы на итерационные функции.forEachВместо того чтобы писать явный цикл, попробуйте использовать функцию forEach вместо этого. Вот так:// Замените это:for (const value of myArray) {  console.log(value)}// на это:forEach(value =&gt; console.log(value), myArray)forEach берёт функцию и массив, и вызывает эту функцию к каждому элементу массива.  В то время как forEach — это наиболее доступная из этих функций, она используется в наименьшей степени при выполнении функционального программирования. Она не возвращает значения, так что она в реальности используется только для вызова функций, которые имеют побочные эффекты.mapСледующая наиболее важная функция, которую мы изучим — это map. Как и forEach, map применяет функцию к каждому элементу массива. Тем не менее, в отличии от forEach, map собирает результат применения это функции в новый массив и возвращает его.Вот примерmap(x =&gt; x * 2, [1, 2, 3])  // --&gt; [2, 4, 6]Он использует анонимную функцию, но мы можем использовать здесь и именованную функцию:const double = x =&gt; x * 2map(double, [1, 2, 3])filter / rejectТеперь, давайте взглянем на filter и reject. Как следует из названия, filter выбирает элементы из массива, на основе некоторой функции. Вот пример:const isEven = x =&gt; x % 2 === 0filter(isEven, [1, 2, 3, 4])  // --&gt; [2, 4]reject делает точно такую же вещь, но в обратном смысле. Она сохраняет элемент для каждой функции, которая вернёт ложное значение, и исключает элемент для тех функций, которые вернут истинное значение.reject(isEven, [1, 2, 3, 4]) // --&gt; [1, 3]findfind применяет функцию к каждому элементу массива и возвращает первый элемент, для которого функция возвращает истинное значение.find(isEven, [1, 2, 3, 4]) // --&gt; 2reducereduce это немного более сложная чем другие функции, которые мы сегодня рассмотрели. Это стоит знать, но если у вас проблемы с пониманием сути её работы, не позволяйте этому останавливать вас. Вы можете пройти довольно долгий путь даже не понимая суть её работы.reduce принимает функцию с двумя аргументами, изначальное значение и массив для работы с ним. Первый аргумент, который будет передан функции, называется «аккумулятором», а вторым аргументом является значение итерируемого массива. Функция должна вернуть новое значение «аккумулятора».const add = (accum, value) =&gt; accum + valuereduce(add, 5, [1, 2, 3, 4]) // --&gt; 15  reduce вызывает функцию (add) с изначальным значением (5) на первом элементе массива (1). add возвращает новое значение аккумулятора (5 + 1 = 6).  reduce снова вызывает add, это время нового значения аккумулятора (6), и следующего значения массива (2). add возвращает 8.  reduce вызывает add снова с 8 и следующим значением (3), результат получается 11.  reduce вызывает add в последний раз с 11 и последним значением массива (4), результатом является 15.  reduce возвращает конечное аккумулируемое значение в качестве результата (15)Простые комбинацииКак только мы усвоили идею прокидывания функций в другие функции, мы можем начать искать ситуации, в которых мы пожелаем объединить несколько функций вместе.  Ramda предоставляет несколько функций для выполнения простых комбинаций. Давайте взглянем на парочку из них:ComplementРанее мы использовали find для нахождения первого чётного числа в списке:Если бы мы пожелали найти первое нечётное число, мы бы могли написать функцию isOdd и использовать её. Но мы также знаем, что любое чётное число не является нечётным. Давайте переиспользуем функцию isEven.Ramda предоставляет complement, функцию высшего порядка, которая берёт другую функцию и возвращает новую функцию, которая возвращает истину, когда оригинальная функция возвращает ложное значение, и ложь, когда оригинальная функция возвращает истинное значение.const isEven = x =&gt; x % 2 === 0find(complement(isEven), [1, 2, 3, 4]) // --&gt; 1Ещё лучше — дать функции-комплементу собственное название, чтобы иметь возможность переиспользовать её:const isEven = x =&gt; x % 2 === 0const isOdd = complement(isEven)find(isOdd, [1, 2, 3, 4]) // --&gt; 1Обратите внимание, что complement реализует ту же самую идею, что и оператор ! для значений в императивных языках программирования.Both / EitherПредставим, что мы работаем над системой голосований. Имея человека, мы хотели бы иметь возможность определить, имеет ли это лицо право на голос. Основываясь на наших текущих знаниях, человек должен быть не моложе 18 лет и должен быть гражданином страны, чтобы иметь возможность голосовать. Кто-то является гражданином этой страны с рождения, а кто-то стал им в результате натурализации.const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRYconst wasNaturalized = person =&gt; Boolean(person.naturalizationDate)const isOver18 = person =&gt; person.age &gt;= 18const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)То, что мы написали выше — работает, но Ramda предлагает несколько удобных функций, которые помогут сделать наш код немного более чистым.Функция both берёт две других функции и возвращает новую функцию, которая вернёт true, если обе функции вернут правдивое значение при применении к ней аргументов, и false в противном случае.either берёт две другие функции и возвращает новую функцию, которая вернёт true, если любая функция возвращает правдивое значение с применёнными к ней аргументами, и false в ином случае.Используя эти две функции, мы можем упростить функции isCitizen и isEligibleToVote:const isCitizen = either(wasBornInCountry, wasNaturalized)const isEligibleToVote = both(isOver18, isCitizen)Обратите внимание, что both, по сути, реализует ту же самую идею, что и оператор && (и) для значений, а either реализует такую же идею для функций, как оператор || (или) для значений.Ramda также предоставляет такие методы как allPass и anyPass, которые берут массив с любым количеством функций. Как подсказывают их имена, allPass работает подобно both, а anyPass подобно either.КонвейерИногда мы хотим применить несколько функций к некоторым данным в конвейерном стиле. Скажем, мы могли бы взять два числа, умножить их вместе, добавить единицу и возвести в квадрат результат. Вы можем написать что-то вроде этого:const multiply = (a, b) =&gt; a * bconst addOne = x =&gt; x + 1const square = x =&gt; x * xconst operate = (x, y) =&gt; {const product = multiply(x, y)const incremented = addOne(product)const squared = square(incremented)return squared}operate(3, 4) // =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169Обратите внимание, что каждая операция применяется к результату предыдущей операции в конвеере.  Ramda предоставляет функцию pipe, которая берёт список одной и более функций и возвращает новую функцию.Новая функция принимает такое же количество аргументов, что и первая. Далее она «передаёт по конвееру» эти аргументы через каждую функцию в списке. Она применяет к первой функции полученные аргументы, передаёт её результат во вторую функцию, и так далее. Результатом последней функции является результат прохождения всего конвеера.Обратите внимание, что все функции после первой должны принимать лишь один аргумент.  Зная это, мы можем использовать функцию pipe для упрощения нашего конвеера.const operate = pipe(  multiply,  addOne,  square)Когда мы вызываем operate(3, 4), pipe функция передаёт 3 и 4 функции multiply, получая в итоге 12. Далее она передаёт 12 в addOne, которая вернёт 13. И далее она передаст 13 в функцию square, который вернёт 169, и это будет финальным результатом всего конвеера.ComposeДругой способ, которым мы могли бы написать нашу оригинальную функцию конвеера — это написать его в одну строку:const operate = (x, y) =&gt; square(addOne(multiply(x, y)))Это гораздо более компактно, но несколько сложнее для чтения. В этой форме, однако, он может быть переписан с использованием функции compose из Ramda.compose работает точно также как и pipe, за исключением того, что он применяет функции справа налево, а не слева направо. Напишем нашу функцию operate с помощью compose:const operate = compose(  square,  addOne,  multiply)Это точно такой же конвеер, как и вышесозданный, но его функции находятся в обратном порядке. По факту, функция compose от Ramda написана на принципах конвеера.  Я всегда думаю о compose следующим образом: compose(f, g)(value) эквивалентно f(g(value)).  Обратите внимание, что как и с pipe, все функции, за исключением последней, должны принимать лишь один аргумент.Compose или pipe?Я думаю, что pipe, вероятно, легче для понимания, когда вы приходите с более императивного поля деятельности, поскольку вы привыкли читать функции слева направо. Но compose, с другой стороны, намного больше похож на вызов нескольких вложенных функций, как я писал выше.ЗаключениеОбъединяя несколько функций определённым образом, мы можем начать писать другие более мощные функции.  Возможно, вы заметили, что в основном мы игнорировали аргументы, когда мы сочетали функции. Мы передаём аргументы лишь тогда, когда мы, наконец, вызываем полученную функцию-конвеер.  Это одна из основ функционального программирования и мы ещё будем много говорить об этом в следующей статьей этой серии, «Частичное применение (каррирование)». Также мы поговорим о том, как сочетать функции, которые принимают больше одного аргумента.",
        "url": "/blog/javascript/2018-05-19-myshlenie-v-stile-ramda-pervye-shagi.html"
    }
    ,
    
    "blog-javascript-2018-05-19-myshlenie-v-stile-ramda-pervye-shagi-2-html": {
        "title": "Мышление в стиле Ramda - частичное применение (каррирование)",
            "author": "",
            "category": "",
            "content": "  Я нашёл Ramda прекрасно спроектированной библиотекой, которая предоставляет множество инструментов для чистого и элегантного функционального программирования в JavaScript.К примеру, давайте скажем, что мы имееем коллекцию объектов книг и мы хотим найти названия всех книг, опубликованных в определённый год. Давайте решим эту проблему, используя только итерирующие функции Ramda:const publishedInYear = (book, year) =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; {  const selected = filter(book =&gt; publishedInYear(book, year), books)  return map(book =&gt; book.title, selected)}Будет хорошо, если мы совместим filter и map в конвеер, но мы не знаем как это сделать, потому что filter и map принимают два аргумента.Также будет хорошо, если нам не будет нужно использовать стрелочные функции в filter. Давайте решим сначала эту проблему, так как это позволит узнать нам некоторые вещи, которые мы можем использовать при создании конвееров:Функции высшего порядкаВ первой части этой серии мы говорили о функциях как о конструкциях первого класса. Подобные функции могут быть переданы как параметры другим функциям и возвращены в качестве результата от других функций. Мы делали много из первого, но ещё не применяли последнее.Функции, которые принимают или возвращают другие функции, также называются «функциями высшего порядка.В примере выше мы передаём стрелочную функцию в filter: book => publishedInYear(book, year), и хорошо бы избавиться от неё. Для того чтобы сделать это, нам нужна функция, которая принимает книгу и возвращает true, если книга была опубликована в нужный год. Но также нам необходимо передать и номер года, чтобы сделать её гибкой.Способ, которым мы можем решить эту проблему — это создание функции, которая вернёт другую функцию. Я напишу это на обычном синтаксисе функций, чтобы вы понимали, что здесь происходит, но далее мы перейдём к более короткой версии со стрелочным синтаксисом:// Полная версия функцииfunction publishedInYear(year) {  return function(book) {    return book.year === year  }}// Стрелочная версия:const publishedInYear = year =&gt; book =&gt; book.year === yearЭто новая версия функции publishedInYear, мы можем переписать вызов filter, исключив стрелочную функцию:const publishedInYear = year =&gt; book =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; {  const selected = filter(publishedInYear(year), books)  return map(book =&gt; book.title, selected)}  Теперь, когда мы вызывем filter, publishedInYear(year) немедленно вызывается и возвращает функцию, которая берёт книгу, что как раз и нужно для filter.Частично примененяемые функции  Мы можем переписать функцию с несколькими аргументами подобным образом, если пожелаем, но не все наши функции должны так работать. Также, мы можем пожелать использовать функции с несколькими аргументами обычным образом.  К примеру, если бы у нас был какой-то другой код, который бы просто хотел проверить, что книга опубликована в определённом году, мы бы хотели написать например так: publishedInYear(book, 2012), но мы не можем писать подобным образом. Вместо этого, нам придётся написать немного по другому: publishedInYear(2012)(book). Это менее читабельно и более раздражительно.К счастью, Ramda предоставляет две функции, чтобы помочь нам в этом: partial и partialRight.Эти две функции позволяют вызывать другую функцию с меньшим числом аргументов, которые ей необходимы. Они оба возвращают новую функцию, которая будет принимать оставшиеся аргументы и вызывать оригинальную функцию уже тогда, когда все аргументы были предоставлены.Разница между partial и partialRight в том, что аргументы, которые мы поставляем, будут подставляться самыми левыми или самыми правыми аргументами, необходимыми для оригинальной функции.Давайте вернёмся назад к нашему оригинальному примеру и попробуем использовать эти функции вместо переписывания publishedInYear. Посколько нам нужно предоставить только год, и это самый правый аргумент, нам нужно использовать partialRight:const publishedInYear = (book, year) =&gt; book.year === yearconst titlesForYear = (books, year) =&gt; {  const selected = filter(partialRight(publishedInYear, [year]), books)  return map(book =&gt; book.title, selected)}Если бы мы написали publishedInYear, принимающей (year, book) вместо (book, year), мы бы использовали partial вместо partialRight.Обратите внимание, что аргументы, которые мы передаём в partial и partialRight, всегда должны быть в массиве, даже если вы передаёте туда только один из них. Я не могу сказать, сколько раз я забывал об этом и получал сбивающее с толку сообщение об ошибке:КаррированиеНеобходимость использовать partial и partialRight везде приводит к многословию и утомлению. Но необходимость вызывать функции с многими аргументами как серию одно-аргументных функций давноценно плоха.К счастью, Ramda предоставляет нам решение: каррирование.curry — это другая основная концепция функционального программирования. Технически, каррированная функция — это всегда серия одно-аргументных функций, о которых я только что жаловался. В чистых функциональных языках, ситаксис выглядит таким образом, что у него нет отличия от вызова функций с нескольмими аргументами.Но потому что Ramda — это JavaScript библиотека, и JavaScript не имеет хорошего синтаксиса для вызова серии одно-аргументных функций, авторы немного смягчили традиционное определение каррирования.В Ramda, каррированная функция может быть вызвана с подмножеством её аргументов, и она вернёт новую функцию, которая будет ожидать получения оставшихся аргументов. Если вы вызываете каррированную функцию со всеми её аргументами, это спровоцирует обычный вызов функции.Вы можете думать о каррированных функциях как о лучшем из двух миров: вы можете вызывать их со всеми аргументами, и они будут просто работать. Или же вы можете вызвать их с частью аргументов, и они будут работать в режиме частичного применения.Давайте применим возможности каррирования к нашей функции publishedInYear. Обратите внимание, что каррирование всегда работает так, как если бы мы использовали функцию partial, и здесь нет возможности использовать версию, подобную partialRight. Далее мы ещё немного поговорим на эту тему, но сейчас мы просто изменим аргументы на обратный порядок в publishedInYear, чтобы год стал идти первым.const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; {  const selected = filter(publishedInYear(year), books)  return map(book =&gt; book.title, selected)}Теперь мы можем единожды вызвать publishedInYear только с годом и получить назад функцию, которая будет брать книгу и вызывать нашу оригинальную функцию. Тем не менее, мы всё ещё можем вызывать обычным образом publishedInYear(2012, book) без раздражающего )( синтаксиса. Лучшее из двух миров!Порядок аргументовОбратите внимание на то, что для того чтобы сделать каррирование работающим для нас, нам необходимо обратить порядок аргументов. Это чрезвычайно распространено в функциональном программировании, так что почти каждая функция Ramda написана так, что данные, с которыми она в конечном счёте работает, идут самыми последними в списке аргументов.  Вы можете думать о первых параметрах как о конфигурации для операции. Так, для publishedInYear, параметр года — это конфигурация (что мы ищем?), а параметр книги — это данные (где мы ищем?).  Мы уже видели примеры этого с итерирующими функциями. Они все использовали коллекцию в качестве последнего аргумента, потому что это делает данный стиль программирования более простым.Аргументы в некорректном порядкеЧто если мы оставим порядок аргументов функции publishedInYear без изменений? Как мы можем всё ещё получить пользу от природы каррирования?  Ramda предоставляет несколько вариантов.FlipПервый вариант — это flip. Flip берёт функцию с двумя и более аргументами и возвращает новую функцию, которая берёт те же аргументы, но меняет местами первые два аргумента. В большинстве случаев она используется с двух-аргументными функциями, но является более общей в применении.  Используя flip, мы можем вернуться к оригинальному порядку аргументов для publishedInYear:const publishedInYear = curry((book, year) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; {  const selected = filter(flip(publishedInYear)(year), books)  return map(book =&gt; book.title, selected)}В большинстве случаев, я бы предпочёл использовать более удобный порядок аргументов, но, к примеру, если вам необходимо использовать такую функцию, которую вы не контроллируете, то flip — это полезный вариант.ЗаполнительБолее общий вариант — это аргумент „заполнитель“ (__).Что если мы имеем каррированную функцию с тремя аргументами, и желаем передать первый и последний аргументы, оставляя тот, который посередине — на будущее? Мы можем использовать заполнитель для серединного аргумента:const threeArgs = curry((a, b, c) =&gt; { /* ... */ })const middleArgumentLater = threeArgs('value for a', __, 'value for c')Мы также можем использовать заменитель более одного раза в вызове. К примеру, что если мы хотим передать только серединный аргумент?const threeArgs = curry((a, b, c) =&gt; { /* ... */ })const middleArgumentOnly = threeArgs(__, 'value for b', __)Мы можем использовать стиль заполнителя вместо flip, если хотим:const publishedInYear = curry((book, year) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; {  const selected = filter(publishedInYear(__, year), books)  return map(book =&gt; book.title, selected)}Я нахожу эту версию более читабельной, но если мне нужно многократно использовать „перевёрнутую“ версию publishedInYear, я могу определить дополнительную функцию, используя flip и далее использовать её везде. Возможно, вы увидите несколько примеров в будущих постах.  Обратите внимание, что __ работает только с каррированными функциями, когда partial, partialRight и flip работают с любой функцией. Если вам необходимо использовать __ с нормальной функцией, вы всегда можете обернуть её вызовом curry перед этим.Давайте сделаем конвеерДавайте посмотрим, как мы можем переместить наши вызовы filter и map внутрь конвеера. Это текущее состояние кода, с удобным порядком аргументов для publishedInYear:const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = (books, year) =&gt; {  const selected = filter(publishedInYear(year), books)  return map(book =&gt; book.title, selected)}Мы узнали о pipe и compose в прошлом посте, но нам необходимо узнать ещё один кусочек информации, чтобы получить полную пользу из этого изучения.Последний кусочек информации следующий: почти каждая Ramda функция каррирована по умолчанию. Это включает в себя filter и map. Так что filter(publishedInYear(year)) прекрасно подходит и возвращает новую функцию, которая просто ожидает, когда её будут переданы книги впоследствии, также как и map(book => book.title).И теперь мы можем написать конвеер:const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = (books, year) =&gt;  pipe(    filter(publishedInYear(year)),    map(book =&gt; book.title)  )(books)Давайте сделаем шаг вперёд и перевернём аргументы для titlesForYear для соответствия соглашениям Ramda о данных, идущих последними. Мы также можем каррировать функцию, чтобы позволить использовать её в последующих конвеерах.const publishedInYear = curry((year, book) =&gt; book.year === year)const titlesForYear = curry((year, books) =&gt;  pipe(    filter(publishedInYear(year)),    map(book =&gt; book.title)  )(books))ЗаключениеДанный пост, возможно — самая глубокая часть из этой серии статей. Частичное применение и каррирование может занять некоторое время и силы, чтобы уложиться в голове. Но когда вы однажды „получите“ их, они познакомят вас с очень мощным способом преобразования данных в функциональном стиле.  Они заставляют нас производить преобразования на основе конвееров, состоящих из маленьких простых строительных блоков.",
        "url": "/blog/javascript/2018-05-19-myshlenie-v-stile-ramda-pervye-shagi-2.html"
    }
    ,
    
    "blog-html-css-2018-05-17-css-cveta-html": {
        "title": "CSS цвета",
            "author": "",
            "category": "",
            "content": "    Есть несколько способов для указания значения цвета, два наиболее распространенных из них это RGB и шестнадцатеричные значения.RGB и RGBAСистема RGB использует три числа, которые описывают относительное количество красного, зеленого и синего цветов, которые смешаны вместе для получения любого оттенка. Числа могут варьироваться от 0 до 255. Рассмотрим RGB-код для темно-фиолетового цвета: rgb(204, 51, 255), его можно например применить к CSS свойству, отвечающему за цвет шрифта:color: rgb(205, 51, 255);Система RGBA добавляет еще одно число, которое описывает прозрачность цвета, значение может варьироваться от 0 (полностью прозрачный) до 1 (полностью непрозрачный). Значение 0.5 делает цвет полупрозрачным, рассмотрим полупрозрачную версию темно-фиолетового цвета, заданную с помощью RGBA системы:color: rgba(204, 51, 255, 0.5);Вы можете увидеть, что значения красного, зеленого и синего цветов аналогичны системе RGB. Четвертое число - 0.5 является степенью прозрачности. Буква \"A\" в RGBA означает альфа-канал, который является термином из графического дизайна означающим прозрачность.    RGBA цвета удобно использовать для создания полупрозрачных элементов, обеспечивающих видимость элементов, располагающихся под ними.HSL и HSLAСистема HSL (hue, saturation, lightness) описывает цвета основанные на оттенке (hue), насыщенности (saturation) и осветлении (lightness). Вот тот же самый темно-фиолетовый цвет, указанный в формате HSL:color: hsl(285, 100%, 60%);Первое число - оттенок, выраженный в градусах от 0 до 360, определяющих позицию цвета на цветовом круге. Второе число - насыщенность, определяемая в процентах от 0% до 100%, указывает насколько насыщенным (ярким) будет цвет. Третье число - осветление, оно определяется в процентах также как и насыщенность, осветление указывает насколько светлым или темным будет цвет.Система HSLA, как и RGBA, добавляет четвертое число в диапазоне от 0 до 1, определяющее насколько прозрачным должен быть цвет. Значение 0.5 делает цвет полупрозрачным, рассмотрим полупрозрачную версию темно-фиолетового цвета, заданную с помощью HSLA системы:color: hsla(285, 100%, 60%, 0.5);Шестнадцатеричные значения цветовШестнадцатеричный код цвета представляет собой шесть символов, стоящих после символа #:Каждый набор двух символов представляет номер от 0 до 255. Так первые два символа представляют красный (red) цвет, следующие два - зеленый (green) и последние два - синий (blue). В этом шестнадцатеричный код очень похож на RGB с тем отличием, что тут каждый цвет задан в шестнадцатеричной системе счисления вместо десятичной.Если каждая пара цифр состоит из одинаковых символов, то значение цвета может быть укорочено. Однако если шестнадцатеричный код выглядит, например, так #bbff10, то такую запись сокращать нельзя.color: #f00;color: #ff0000;",
        "url": "/blog/html-css/2018-05-17-css-cveta.html"
    }
    ,
    
    "blog-html-css-2018-05-16-blok-s-prokruchivaemym-tekstom-s-pomoshchyu-css-i-html-html": {
        "title": "Как создать div блок с прокруткой?",
            "author": "",
            "category": "",
            "content": "\tСвойство overflow отвечает за отображение содержания блочного элемента. Можно применить в том случае, когда контент не помещается полностью и выходит за область блока.overflow-x - отвечает за отображением содержания блочного элемента по горизонтали.overflow-y - отвечает за отображением содержания блочного элемента по вертикали..prokrutka {\toverflow: auto; /* свойство для прокрутки по горизонтали. Автоматом, если содержимое больше блока */}Свойства и значения overflow\tvisible - отображается все содержание элемента, даже за пределами установленной ширины. \thidden - отображается только область внутри элемента, остальное скрыто.\tscroll - принудительно добавляется горизонтальная (y) или вертикальная (x) полоса прокрутки.\tauto - автоматом добавляется горизонтальная полоса прокрутки, в случае если блок меньше. Рассмотри пример класса CSS. В width и height устанавливаем нужные нам ширину и высоту блока (за них не будет выходить содержимое блока), а свойством overflow: auto; задаем прокрутку по горизонтали в случае надобности.prokrutka {\twidth:150px; /* ширина нашего блока */\theight:100px; /* высота нашего блока */\tbackground: #fff; /* цвет фона, белый */\tborder: 1px solid #C1C1C1; /* размер и цвет границы блока */\toverflow: auto; /* свойство для прокрутки по горизонтали. Автоматом, если больше блока */}Принудительная установка прокрутки в блоке CSSМожно также принудительно создать прокрутку по высоте и ширине. Для этого каждой оси: overflow-y: scroll; (вертикаль) overflow-x: scroll; (горизонталь) укажем параметр scroll, принудительная прокрутка. .prokrutka {\theight:150px; /* высота нашего блока */\tbackground: #fff; /* цвет фона, белый */\tborder: 1px solid #C1C1C1; /* размер и цвет границы блока */\toverflow-x: scroll; /* прокрутка по горизонтали */\toverflow-y: scroll; /* прокрутка по вертикали */}Пример div блока с прокруткой&lt;div class=\"prokrutka\"&gt;\tА тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации. А тут много-много разного текста и прочей информации.&lt;/div&gt;.prokrutka {\theight: 200px; /* высота нашего блока */\twidth: 200px; /* ширина нашего блока */\tbackground: #fff; /* цвет фона, белый */\tborder: 1px solid #C1C1C1; /* размер и цвет границы блока */\toverflow-x: scroll; /* прокрутка по горизонтали */\toverflow-y: scroll; /* прокрутка по вертикали */}Одно из свойств overflow можно убрать, тогда останется прокрутка только по одной оси, чего вполне достаточно.\tПосмотреть работу скрипта на примере ниже.\tSee the Pen WJYVqp by Igor Gorbov (@igorgorbov) on CodePen.\tМожно указать принудительную прокрутку только для одной оси. Для этого соответственно уберите строку либо с overflow-x, либо с overflow-y.",
        "url": "/blog/html-css/2018-05-16-blok-s-prokruchivaemym-tekstom-s-pomoshchyu-css-i-html.html"
    }
    ,
    
    "blog-javascript-2018-05-16-javascript-async-await-za-10-minut-html": {
        "title": "JavaScript Async/Await за 10 минут",
            "author": "",
            "category": "",
            "content": "  Async/Await - это долгожданная функция JavaScript, которая делает работу с асинхронными функциями более приятной и понятной. Он построен поверх Promises и совместим со всеми существующими API-интерфейсами на основе Promise.Что такое Async/Await?Название происходит от async и await - двух ключевых слов, которые помогут нам очистить наш асинхронный код:async - объявляет асинхронную функцию (async function someName(){...})  Автоматически преобразует обычную функцию в Promise.  Функции async резолвят (resolve) всё, что возвращается в их теле.  Асинхронные функции позволяют использовать await.await - приостанавливает выполнение функции (let result = await someAsyncCall();)  Когда await помещен перед вызовом Promise, await приостанавливает выполнение кода, следующего за ним, заставляя скрипт ждать возвращения результата выполняемого Promise'а.  await работает только с Promise'ами, он не работает с обычными колбэками.  await может использоваться только внутри асинхронных функций.Вот простой пример, который, надеюсь, прояснит ситуацию:  Предположим, мы хотим получить некоторый JSON-файл с сервера. Мы напишем функцию, которая использует библиотеку axios и отправляет HTTP-запрос GET для  https://tutorialzine.com/misc/files/example.jsonДля его получения, мы должны ждать ответа от сервера, поэтому, естественно, HTTP-запрос будет асинхронным.Ниже мы видим, что одна и та же функция реализована дважды. Сначала с Promise, затем второй раз с использованием Async/Await.// Вариант с Promisefunction getJSON(){  // Чтобы блокировать функцию, создаем Promise  return new Promise( function(resolve) {    axios.get('https://tutorialzine.com/misc/files/example.json')    .then( function(json) {      // Ответ от сервера доступен в блоке .then      // Возвращаем результат с помощью функции resolve      resolve(json);    });  })}// Вариант Async/Await// Ключевое слово async автоматически создаст новый Promise и возвратит егоasync function getJSONAsync(){  // Ключевое слово await позволяет нам не писать блок .then  let json = await axios.get('https://tutorialzine.com/misc/files/example.json');  // Ответ на GET запрос сохранен в переменной json  // Возвращаем его как в обычной синхронной функции  return json;}Явно, что версия на Async/Await короче и читается легче. Помимо используемого синтаксиса обе функции идентичны - они обе возвращают Promise и резолвятся с JSON ответом от axios. Мы можем вызвать async функцию вот так:getJSONAsync().then( function(result) {  // Сделать что-нибудь с результатом.});Итак, делает ли Async/Await устаревшими Promise'ы?Нет. При работе с Async/Await мы все еще используем Promise под капотом. Хорошее понимание Promise'ов, на самом деле, очень рекомендуется и поможет вам в долгосрочной перспективе.Есть даже случаи, когда Async/Await не сокращают код, и приходится возвращаться к Promise за помощью. Один из таких случаев - это когда нам нужно сделать несколько независимых асинхронных вызовов и дождаться их завершения.Если мы попытаемся сделать это с помощью async и ожидаем, произойдет следующее:async function getABC() {  let A = await getValueA(); // getValueA займет 2 секунды  let B = await getValueB(); // getValueB займет 4 секунды  let C = await getValueC(); // getValueC займет 3 секунды  return A*B*C;}Каждый вызов await будет ждать, пока предыдущий не вернет результат. Поскольку мы выполняем один вызов за раз, вся функция займет 9 секунд от начала до конца (2 + 4 + 3).Это не оптимальное решение, так как три переменные A, B и C не зависят друг от друга. Другими словами, нам не нужно знать значение A до того, как мы получим B. Мы можем получить их в одно и то же время и уменьшить время ожидания.Чтобы отправить все запросы одновременно, требуется Promise.all(). Это позволит убедиться, что у нас есть все результаты, прежде чем продолжить, но асинхронные вызовы будут запускаться параллельно, а не один за другим.async function getABC() {  // Promise.all() позволяет выполнить все функции одновременно  let results = await Promise.all([ getValueA, getValueB, getValueC ]);  return results.reduce((total,value) =&gt; total * value);}Таким образом, функция займет гораздо меньше времени. Вызовы getValueA и getValueC будут уже завершены к концу getValueB. Таким образом мы сокращаем время исполнения скрипта до времени самого медленного (getValueB()), а не суммы всех взятых.Обработка ошибок в Async/AwaitЕще одна отличная вещь в Async/Await заключается в том, что она позволяет нам обнаруживать любые неожиданные ошибки в старом блоке try/catch. Нам просто нужно обернуть наши await следующим образом:async function doSomethingAsync(){  try {  // Этот запрос может вызваться с ошибкой  let result = await someAsyncCall();  }  catch(error) {  // Если была ошибка - перехват ошибки будет тут  }}Блок catch будет обрабатывать ошибки, вызванные ожидаемыми (await) асинхронными вызовами или любым другим падающим с ошибкой кодом, который мы запишем внутри блока try.Если нужно, мы также можем перехватить ошибки при выполнении функции async. Поскольку все функции async возвращают Promise'ы, мы можем просто включить обработчик события .catch() при их вызове.// Async функция без блока try/catchasync function doSomethingAsync(){  // Этот асинхронный запрос может вызвать ошибку  let result = await someAsyncCall();  return result;}// Перехватываем ошибку при вызове функцииdoSomethingAsync()  .then(successHandler)  .catch(errorHandler);Важно выбрать, какой метод обработки ошибок вы предпочитаете, и придерживаться его. Использование try/catch и .catch() одновременно, скорее всего, приведет к проблемам.Поддержка браузерамиAsync/Await уже доступен в большинстве основных браузеров. Исключение составляет только IE11 - все остальные производители поймут ваш код на async/await без необходимости использования полифилов.Можно убедиться в этом по ссылке http://caniuse.com/#search=await.  Если же такая совместимость вам не подходит, тогда всегда можно прибегнуть к транспайлерам вроде Babel или TypeScript.",
        "url": "/blog/javascript/2018-05-16-javascript-async-await-za-10-minut.html"
    }
    ,
    
    "blog-javascript-2018-05-16-async-function-html": {
        "title": "Async function в JavaScript",
            "author": "",
            "category": "",
            "content": "  Объявление async function определяет асинхронную функцию, которая возвращает объект AsyncFunction.  Вы также можете  определить async-функции, используя  выражение async function.ОписаниеПосле вызова функция async возвращает Promise. Когда результат был получен, Promise завершается, возвращая полученное значение.  Когда функция async выбрасывает исключение, Promise ответит отказом с выброшенным (throws) значением.Функция async может содержать выражение await, которое приостанавливает выполнение функции async и ожидает ответа от переданного Promise, затем возобновляя выполнение функции async и возвращая полученное значение.Ключевое слово await допустимо только в асинхронных функциях. В другом контексте вы получите ошибку SyntaxError.Простой примерfunction resolveAfter2Seconds(x) {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; {      resolve(x);      }, 2000);  });}async function add1(x) {  const a = await resolveAfter2Seconds(20);  const b = await resolveAfter2Seconds(30);  return x + a + b;}add1(10).then(v =&gt; {  console.log(v);  // prints 60 after 4 seconds.});async function add2(x) {  const a = resolveAfter2Seconds(20);  const b = resolveAfter2Seconds(30);  return x + await a + await b;}add2(10).then(v =&gt; {  console.log(v);  // prints 60 after 2 seconds.});Когда функция async выбрасывает исключениеasync function throwsValue() {  throw new Error('oops');}throwsValue()  .then((resolve) =&gt; {    console.log(\"resolve:\" + resolve);  },  (reject) =&gt; {    console.log(\"reject:\" + reject);  });//prints \"reject:Error: oops\"//orthrowsValue()  .then((resolve) =&gt; {    console.log(\"resolve:\" + resolve);  })  .catch((reject) =&gt; {    console.log(\"reject:\" + reject);  });//prints \"reject:Error: oops\"API, которое возвращает Promise, будет возвращать значение в цепочке, тем самым разбивая функцию на много частей. Рассматривая следующий код:function getProcessedData(url) {  return downloadData(url) // returns a promise  .catch(e =&gt; {    return downloadFallbackData(url) // returns a promise  })  .then(v =&gt; {    return processDataInWorker(v); // returns a promise  });}он может быть переписан с одним использованием функции async:async function getProcessedData(url) {  let v;  try {    v = await downloadData(url);  } catch(e) {    v = await downloadFallbackData(url);  }  return processDataInWorker(v);}Заметьте, что пример выше не содержит await на return, потому что возвращаемое значение функции async неявно обернуто в Promise.resolve.",
        "url": "/blog/javascript/2018-05-16-async-function.html"
    }
    ,
    
    "blog-html-css-2018-05-15-proizvoditelnyy-parallaks-html": {
        "title": "Производительный параллакс",
            "author": "",
            "category": "",
            "content": "    Любите вы параллакс или ненавидите его, но он никуда не денется. При разумном использовании он может добавить веб-приложению глубину и утонченность. Проблема заключается в том, что реализовать параллакс производительно — это непросто. В этой статье мы обсудим решение, которое одновременно и производительное, и, что важно, кросс-браузерное.TL;DRНе используйте события прокрутки или background-position для реализации параллакса.    Для более правильного эффекта параллакса используйте CSS 3D трансформации.    Для Mobile Safari используйте position: sticky для обеспечения распространения эффекта параллакса.    Если вам нужно готовое решение, возьмите Parallax helper JS  из репозитория UI Element Samples.Проблемы параллаксаДля начала рассмотрим два общих способа реализации эффекта параллакса, в частности, почему они нам не подходят. Плохо: использование событий прокрутки    Ключевое требование параллакса — он должен быть связан с прокруткой страницы; каждому изменению позиции скролла должно соответствовать изменение позиции элементов, к которым применяется параллакс.    Это звучит просто, но важный механизм современных браузеров — это возможность работать асинхронно. Это применимо, в нашем случае, к событию scroll. В большинстве браузеров обработчики события scroll выполняются по принципу «лучшее из возможного» (в оригинале — «best-effort», прим. переводчика) и не гарантируют анимацию при каждом изменении положения скролла!Эта важная информация говорит нам о том, почему мы должны избегать основанного на JavaScript решения, которое перемещает элементы на основе событий прокрутки: JavaScript не гарантирует, что параллакс будет соответствовать позиции скролла. В более старых версиях Mobile Safari события прокрутки фактически срабатывали в конце прокрутки, что сделало невозможным реализацию эффекта параллакса на основе событий прокрутки. В более поздних версиях анимация отображается во время прокрутки, но, как и в Chrome, по принципу «лучшее из возможного». Если основной поток занят какой-либо другой работой, события прокрутки не будут выполняться немедленно, что означает, что эффект параллакса будет потерян.Плохо: обновление background-positionДругая ситуация, которой мы хотели бы избежать — это отрисовка на каждом кадре. Многие решения пытаются изменить положение фона, чтобы обеспечить эффект параллакса, тем самым заставляя браузер перерисовывать затронутые части страницы при прокрутке. Такое решение может быть достаточно дорогостоящим, чтобы значительно затормозить анимацию.    Если мы хотим реализовать эффект параллакса, мы должны применить решение на основе аппаратно ускоренных свойств (на данный момент это transform и opacity), которые не зависят от событий прокрутки.CSS в 3DИ Скотт Келлум, и Кит Кларк проделали значительную работу в области использования CSS 3D для реализации эффекта параллакса. Техника, которую они эффективно используют, такова:    Установить для контейнера свойство overflow-y: scroll (и возможно overflow-x: hidden).    Для этого же элемента применить значение perspective, а свойство perspective-origin установить в top left или 0 0.    Для дочерних элементов применить перемещение по оси Z и масштабировать их, чтобы обеспечить эффект параллакса, не влияя на их размер на экране.CSS для этого выглядит так:.container {    width: 100%;    height: 100%;    overflow-x: hidden;    overflow-y: scroll;    perspective: 1px;    perspective-origin: 0 0;}.parallax-child {    transform-origin: 0 0;    transform: translateZ(-2px) scale(3);}Эти правила могут быть применены к фрагменту кода:&lt;div class=\"container”&gt;    &lt;div class=\"parallax-child”&gt;&lt;/div&gt;&lt;/div&gt;Настройка масштаба для перспективы    Перемещение элемента на задний план делает его меньше пропорционально значению перспективы. Рассчитать, насколько нужно масштабировать элемент можно по формуле: (perspective — distance) / perspective. Поскольку мы хотим, чтобы элемент был параллаксным, но сохранил исходный размер, мы должны масштабировать его таким образом.В случае, показанном выше, перспектива равна 1px, а расстояние Z для parallax-child равно −2px. Это означает, что элемент должен быть увеличен до 3x. Это вы можете видеть в коде: scale(3).Для любого элемента, не имеющего значения translateZ, вы можете заменить значение расстояния на ноль. Это означает, что масштаб будет равен (perspective — 0) / perspective, т.е. 1. Этот элемент не нужно масштабировать ни вверх, ни вниз. Очень удобно, правда.Как работает этот подходВажно понять, почему этот подход работает, т.к. скоро мы будем использовать эти знания. Прокрутка фактически является преобразованием, поэтому ее можно аппаратно ускорить; в основном это связано с перемещением слоев с помощью GPU. В обычном скроллинге без перспективы, прокрутка происходит в отношении 1:1, если сравнивать прокрутку контейнера и дочерних элементов. Если вы прокрутите элемент вниз на 300px, элементы переместятся также на 300px.менение значения перспективы вносит рассинхронизацию в этот процесс; это значение меняет матрицы, лежащие в основе преобразования прокрутки. Теперь прокрутка на 300px может перемещать дочерние элементы, например, на 150px, в зависимости от выбранной перспективы и значений translateZ. Если значение translateZ элемента равно 0, он будет прокручиваться в отношении 1:1 (как это было раньше), но дочерний элемент, сдвинутый в направлении Z от точки перспективы, будет прокручиваться с другой скоростью! Чистый результат: эффект параллакса. И, что очень важно, это автоматически обрабатывается как часть внутреннего устройства прокрутки браузера, что означает, что нет необходимости слушать события прокрутки или менять положение фона.Ложка дегтя: Mobile SafariЕсть одно важное предостережение, касающееся сохранения 3D-эффектов для дочерних элементов. Если добавить элементы в иерархию между элементом с перспективой и его параллаксными детьми, 3D перспектива «сплющится», а это означает, что эффект будет потерян.&lt;div class=\"container\"&gt;    &lt;div class=\"parallax-container\"&gt;        &lt;div class=\"parallax-child\"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;В коде выше добавился элемент .parallax-container, это фактически делает перспективу плоской и эффект параллакса будет потерян. Решение в большинстве случаев довольно просто: вы добавляете правило transform: preserve-3d к элементу, заставляя его тем самым распространять дальше по дереву любые 3D-эффекты (например, наше значение перспективы), которые были применены..parallax-container {    transform-style: preserve-3d;}В случае с Mobile Safari, однако, все немного запутанно. Применение к контейнеру правила overflow-y: scroll технически работает, но за счет переброски прокручиваемых элементов. Решение заключается в добавлении -webkit-overflow-scrolling: touch, но это также сгладит перспективу, и мы не получим никакого параллакса.С точки зрения прогрессивного улучшения это, вероятно, не слишком большая проблема. Если мы не сможем реализовать параллакс во всех браузерах, наше приложение все равно будет работать, но было бы неплохо разобраться с этим.position: sticky придет на помощь!В описанной выше ситуации на помощь приходит свойство position: sticky, которое при скролле позволяет элементу «прилипнуть» к верхнему краю вьюпорта или родительского элемента. Спецификация довольно обширна, но есть в ней один полезный маленький камушек:Блок с position: sticky позиционируется аналогично блоку с position: relative, но смещение вычисляется относительно ближайшего предка с полосой прокрутки или относительно вьюпорта, если ни один из предков не имеет полосы прокрутки. На первый взгляд это может показаться малозначительным, но ключевым моментом в этом предложении является то, как именно вычисляется липкость элемента: «смещение вычисляется по отношению к ближайшему предку с полосой прокрутки». Другими словами, расстояние для перемещения липкого элемента (пока он не станет прикрепленным к другому элементу или к вьюпорту) вычисляется до применения любых других преобразований, а не после. Это означает, что, подобно примеру ранее, если смещение было рассчитано на 300 пикселей, есть возможность использовать перспективу (или любое другое преобразование), чтобы манипулировать этим значением смещения в 300 пикселей, прежде чем оно будет применено к любым липким элементам.&lt;div class=\"container”&gt;  &lt;div class=\"parallax-container”&gt;    &lt;div class=\"parallax-child\"&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;.container {    overflow-y: scroll;    -webkit-overflow-scrolling: touch;}.parallax-container {    perspective: 1px;}.parallax-child {    position: -webkit-sticky;    top: 0px;    transform: translate(-2px) scale(3);}Это восстанавливает эффект параллакса для Mobile Safari, что является отличной новостью!Оговорки для липкого позиционированияЕсть одна оговорка: position: sticky изменяет механизм параллакса. Липкое позиционирование пытается, скажем, прикрепить элемент к прокручивающемуся контейнеру, тогда как «не-липкое» позиционирование этого не делает. Это означает, что параллакс с липким позиционированием оказывается противоположным:    С position: sticky чем ближе элемент к z=0, тем меньше он движется.    Без position: sticky чем ближе элемент к z=0, тем больше он движется.Если это кажется абстрактным, посмотрите демо Роберта Флэка , которое показывает, как по-разному ведут себя элементы с и без липкого позиционирования. Чтобы увидеть разницу, вам понадобится Chrome Canary (на момент написания статьи версия 56) или Safari.Демо Роберта Флэка, показывающее, как position: sticky влияет на эффект параллакса.Различные ошибки и обходные путиКак всегда, в этом решении есть острые углы, которые необходимо сгладить:    Поддержка липкого позиционирования неполная. Поддерживается в Chrome, в Edge поддержка отсутствует полностью, в Firefox есть ошибки при комбинировании position: sticky и перспективы. В таких случаях стоит добавлять position: sticky (версию с префиксом -webkit), когда это необходимо, только для Mobile Safari.    Эффект не «просто работает» в Edge. Edge пытается обработать прокрутку на уровне OC, что в целом хорошо, но в данном случае не позволяет обнаружить изменение перспективы во время прокрутки. Чтобы исправить это, вы можете добавить элемент с position: fixed, это переключит Edge на прокрутку без использования ОС и гарантирует учет изменений перспективы.    «Содержание страницы стало просто огромным!». Многие браузеры учитывают масштаб при определении размера страницы, но, к сожалению, Chrome и Safari не учитывают перспективу. При масштабе — скажем — 3x, примененном к элементу, вы можете хорошо видеть полосы прокрутки и т.п., даже если элемент находится в масштабе 1x после применения перспективы. Можно обойти эту проблему, масштабируя элементы из нижнего правого угла (transform-origin: bottom right). Это работает, потому что заставляет элементы расти в «отрицательную область».ЗаключениеПараллакс — забавный эффект при вдумчивом использовании. Как вы могли убедиться, существует производительный, кросс-браузерный и связанный со прокруткой способ его реализации. Поскольку для достижения желаемого эффекта требуется немного математики и небольшое количества шаблонов, мы обернули это решение в небольшую вспомогательную библиотеку и пример, которые вы можете найти в    нашем репозитории UI Element Samples.Поиграйте, и дайте нам знать, что получится.",
        "url": "/blog/html-css/2018-05-15-proizvoditelnyy-parallaks.html"
    }
    ,
    
    "blog-html-css-2018-05-14-kak-sozdat-adaptivnuyu-setku-html": {
        "title": "Как создать адаптивную сетку",
            "author": "",
            "category": "",
            "content": "\tАдаптивная сетка — один из лучших инструментов для создания уникального дизайна. Вы можете настроить всё, что нужно — количество и ширину колонок, отступы и даже контрольные точки, при достижении которых перестраивается раскладка страницы.К сожалению, большинство людей даже не пытаются создавать свои сетки из-за того, что им не хватает знаний и уверенности в своих силах.\tВ этой статье я хочу помочь вам обрести веру в себя и знания, нужные для создания собственной сетки. Надеюсь, после прочтения статьи вы отложите фреймворки и попробуете создать собственную сетку для следующего проекта.Что входит в сетку?Прежде чем браться за создание сетки, вам нужно сделать три вещи.1. Спроектировать сеткуСколько будет колонок? Они будут одинаковой или разной ширины? Какие у них будут ширина и отступы? Вы сможете правильно просчитать параметры сетки только после того, как ответите на эти вопросы. Чтобы помочь вам, я написал статью о проектировании сеток. Прочтите её, что бы научиться грамотно проектировать сетки.2. Понять поведение сетки на разных вьюпортахБудете ли вы менять размеры колонок и отступов пропорционально ширине вьюпорта? Или вы будете менять только ширину колонок, оставляя отступы фиксированными? Может вы будете менять количество колонок в определённых контрольных точках?\tНа эти вопросы тоже нужно ответить. Это поможет рассчитать ширину колонок и отступов.3. Понять, нравится ли вам писать классы в разметкеКогда речь заходит о сетках, мир фронтенда делится на два лагеря. Один пишет сеточные классы в разметке (например, такой подход используют Bootstrap и Foundation). Я называю это HTML-сетками. Разметка выглядит так:&lt;div class=\"container\"&gt;\t&lt;div class=\"row\"&gt;\t\t&lt;div class=\"col-md-9\"&gt;Content&lt;/div&gt;\t\t&lt;div class=\"col-md-3\"&gt;Sidebar&lt;/div&gt;\t&lt;/div&gt;&lt;/div&gt;Другие создают сетки на CSS. Я называю это CSS-сетками.С CSS-сетками разметка получается проще, чем с HTML-сетками. Вам не приходится повторять одни и те же классы, размечая визуально похожие части документа. Также вам не нужно помнить, как называются классы сетки:&lt;div class=\"content-sidebar\"&gt;\t&lt;div class=\"content\"&gt;&lt;/div&gt;\t&lt;div class=\"sidebar\"&gt;&lt;/div&gt;&lt;/div&gt;С другой стороны, стили в случае с CSS-сетками получаются сложнее. Придётся думать, чтобы добиться простого решения задачи — если только вы ещё не решали её до сих пор.А что выбрал бы я?Как и многие эксперты фронтенда, я выбираю CSS-сетки, хотя и не смею называть себя экспертом.В любом случае, вам нужно определиться с тремя вещами, прежде чем создавать свою сетку. Вот они, если кратко:\tДизайн сетки;\tКак сетка ведёт себя на разных вьюпортах;\tИспользовуется CSS- или HTML-сетка.Мы можем двигаться дальше, только определившись с этими вещами. В этой статье условия такие:\tСетка имеет максимальную ширину 1140 px, 12 колонок по 75 px и отступы в 20 px.\tКолонки меняют свой размер пропорционально вьюпорту, а отступы остаются фиксированными.\tЯ собираюсь создавать CSS-сетку. Итак, давайте начнём!Создаём сеткуПроцесс создания сетки состоит из восьми шагов:\tВыбор технологии реализации\tУстановка box-sizing: border-box;\tСоздание контейнера сетки;\tРасчёт ширины колонок;\tОпределение положения отступов;\tСоздание отладочной сетки;\tСоздание вариаций раскладки;\tАдаптация раскладки.Большинство из этих шагов становятся достаточно простыми, как только вы проходите их хотя бы раз. Я объясню всё, что нужно знать для прохождения каждого из них.Шаг 1: выбор технологииЧто вы будете использовать для создания сетки — CSS-гриды, флексы или старые добрые флоаты? Решения и детали реализации зависят от выбранной технологии.CSS-гриды, безусловно, лучше всего подходят для создания сетки (потому, что гриды 😎). К сожалению, сегодня поддержка гридов оставляет желать лучшего. В каждом браузере они скрыты за флагом, поэтому мы не будем рассматривать гриды в этой статьеПерейдём к флексам и флоатам. Соображения по их применению схожи, так что можете выбрать то, что вам по душе и двигаться далее. Я буду использовать флоаты, потому что они проще и понятнее новичкам.Если вы выбрали флексы, помните об отличиях от флоатов, которые нужно учесть.Шаг 2: установка box-sizingСвойство box-sizing задаёт блочную модель, которую браузеры используют для расчёта свойств width и height. Выставляя свойству box-sizing значение border-box, мы сильно упрощаем расчёт размеров колонок и отступов, позже вы поймёте, почему.Вот наглядный пример того, как вычисляется width в зависимости от значения свойства box-sizing:Обычно я устанавливаю значение border-box для всех элементов на сайте, благодаря чему расчёт ширины и высоты элементов работает последовательно и интуитивно понятно. Вот как я это делаю:html {\tbox-sizing: border-box;\t}*,*:before,*:after {\tbox-sizing: inherit;}Шаг 3: создание контейнера сеткиУ каждой сетки есть контейнер, определяющий её максимальную ширину. Как правило, я называю его .l-wrap. Префикс .l- означает layout (раскладка)..l-wrap {\tmax-width: 1140px;\tmargin-right: auto;\tmargin-left: auto;}Примечание: для лучшей доступности и адаптивности я настоятельно рекомендую использовать вместо пикселей относительные единицы измерения вроде em или rem. В примерах я использую пиксели, потому что они проще для понимания.Шаг 4: расчёт ширины колонокПомните, что мы используем флоаты для вёрстки колонок и отступов? С флоатами мы можем использовать только пять CSS-свойств для создания колонок и отступов, в случае с флексами, их немного больше.\twidth\tmargin-right\tmargin-left\tpadding-right\tpadding-leftЕсли вы помните, при использовании CSS-сеток разметка выглядит примерно так:&lt;div class=\"l-wrap\"&gt;\t&lt;div class=\"three-col-grid\"&gt;\t\t&lt;div class=\"grid-item\"&gt;Элемент сетки&lt;/div&gt;\t\t&lt;div class=\"grid-item\"&gt;Элемент сетки&lt;/div&gt;\t\t&lt;div class=\"grid-item\"&gt;Элемент сетки&lt;/div&gt;\t&lt;/div&gt;&lt;/div&gt;Из этой разметки понятно, что сетка имеет всего три колонки. Также видно, что для создания отступов нет дополнительных div. Это означает, что:\tМы создаём колонки с помощью свойства width;\tМы создаём отступы с помощью свойств margin или padding.Думать о колонках и отступах одновременно сложно, поэтому давайте для начала представим, что делаем сетку без отступов.\tЭта сетка будет выглядеть примено так:А теперь нужно произвести несколько математических вычислений. Мы знаем, что сетка имеет максимальную ширину в 1140 px, значит ширина каждой колонка — 380 px (1140 ÷ 3)..three-col-grid .grid-item {\twidth: 380px;\tfloat: left;}Пока всё хорошо. Мы сделали сетку, которая отлично работает на вьюпортах больше 1140 px. К сожалению, всё ломается, когда вьюпорт становится меньше.Из-за этого мы не можем использовать пиксели. Нам нужна единица измерения, которая зависит от ширины контейнера: это проценты. Давайте зададим ширину колонок в процентах:.three-col-grid .grid-item  {\twidth: 33.33333%;\tfloat: left;}Код выше задаёт простую резиновую трёхколоночную сетку без отступов. Колонки меняют свою ширину пропорционально ширине окна браузера.Прежде чем двигаться дальше, нужно уточнить одну вещь. Когда все дочерние элементы контейнера плавающие (им задано свойство float), высота контейнера обнуляется. Это явление называется схлопыванием флоатов. Контейнер ведёт себя так, будто в нём нет дочерних элементов:Чтобы это исправить, нам нужен клиар-фикс. Он выглядит так:.three-col-grid::after {\tdisplay: table;\tclear: both;\tcontent: '';}Если вы используете препроцессор вроде Sass, вы можете сделать примесь, чтобы использовать этот код удобно в разных местах:// Clearfix@mixin clearfix {\t&amp;::after {\t\tdisplay: table;\t\tclear: both;\t\tcontent: '';\t}}// Usage.three-col-grid {\t@include clearfix;}Мы разобрались с колонками. Следующий шаг — отступы.Шаг 5: определение положения отступовПока мы только знаем, что их можно реализовать с помощью свойств margin и padding. Но какое из них следует выбрать?Сделав несколько попыток, вы быстро поймёте, что есть четыре возможных способа как сделать эти отступы: внешние, margin и внутренние, padding. Отступы могут быть расположены:\tС одной стороны, внешние;\tС одной стороны, внутренние;\tРавномерно с обеих сторон, внешние;\tРавномерно с обеих сторон, внутренние.Здесь начинаются сложности. Вам нужно по-разному рассчитать ширину колонок в зависимости от используемого метода. Рассмотрим эти методы один за другим и посмотрим на разницу. Не торопитесь, пока читаете.\tПоехали:Метод 1: внешние односторонние отступыИспользуя этот метод, вы создаете отступы с помощь margin. Этот отступ будет расположен слева или справа от колонки. Вам решать, какую сторону выбрать.\tВ рамках этой статьи, давайте предположим, что вы задаете отступы справа. Вот что вы будете делать:.grid-item {\tmargin-right: 20px;\tfloat: left;}Затем пересчитываете ширину колонки как на картинкеКак вы видите на картинке выше, 1140 px это три колонки и два отступа.И тут появляется проблема… Нам нужно, чтобы колонки были описаны в процентах, но в то же время отступы зафиксированы на ширине 20 px. Мы не можем делать вычисления с двумя разными единицами измерения одновременно!Это было невозможно раньше, но возможно сейчас.\tВы можете использовать CSS-функцию calc для сочетания процентов с другими единицами измерения. Она на лету извлекает значение процентов для выполнения вычислений.Это значит, что вы можете задать ширину в виде функции, и браузер автоматически рассчитает ее значение:.grid-item {\twidth: calc((100% - 20px * 2) / 3);}Это круто. После получения ширины колонки, вам нужно удалить последний отступ у крайнего правого элемента сетки. Вот как это можно сделать:.grid-item:last-child {\tmargin-right: 0;}Чаще всего, когда вы удаляете последний отступ у крайнего правого элемента, вы также хотите задать ему обтекание по правой стороне для предотвращения ошибок субпикселного округления, из-за которых ваша сетка переносит последний элемент на новую строку. Это происходит только в браузерах, которые округляют пиксели.Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку.​.grid-item:last-child {\tmargin-right: 0;\tfloat: right;}Фух. Почти готово. И ещё одна вещь.\tНаш код хорош только в том случае, если сетка содержит лишь одну строку. Но он не справляется, если строк с элементами больше, чем одна 😢Нам нужно удалить правый внешний отступ у каждого крайнего правого элемента в каждой строке. Лучший способ это сделать — использовать nth-child:.grid-item:nth-child(3n+3) {\tmargin-right: 0;\tfloat: right;}Метод 2: внутренние односторонние отступыКак и с внешними односторонними отступами, в этом методе требуется разместить отступы на одной из сторон колонки. Предположим, что вы снова выбрали правую сторону..grid-item {\tpadding-right: 20px;\tfloat: left;}Затем, вы можете пересчитать ширину колонки как на картинке:Обратили внимание, что ширина отличается от предыдущего метода? Мы переключили свойство box-sizing в border-box. Теперь width рассчитывается, включая в себя padding.В этом случае, две из трёх колонок имеют бо́льшую ширину, чем последняя, что в конечном итоге приводит к причудливым расчётам и делает CSS трудным для понимания.\tЯ предлагаю даже не продолжать с этим методом. Всё обернётся действительно страшно. Пробуйте на свой страх и риск.Метод 3: внешние разделённые отступыВ этом методе мы разделяем отступы на две части и размещаем по половине с каждой стороны колонки. Код выглядит примерно так:.grid-item {\tmargin-right: 10px;\tmargin-left: 10px;\tfloat: left;}Затем пересчитываем ширину колонки как на картинке:Как мы узнали ранее, рассчитать ширину колонки можно с помощью функции calc. В этой ситуации мы отнимаем три отступа от 100%, прежде чем делить ответ на три для получения ширины колонки. Другими словами, ширина колонки будет calc((100% - 20px * 3) / 3)..grid-item {\twidth: calc((100% - 20px * 3) / 3);\tmargin-right: 10px;\tmargin-left: 10px;\tfloat: left;}Это всё! Вам не нужно ничего дополнительно делать для сеток с несколькими строками 😉Метод 4: внутренние разделённые отступыЭтот метод аналогичен предыдущему. Мы делили отступы и размещали их с каждой стороны колонки. На этот раз мы используем padding:.grid-item {\tpadding-right: 10px;\tpadding-left: 10px;\tfloat: left;}Затем вы рассчитываете ширину колонки так:Обратили внимание, что в этом случае гораздо легче делать расчеты? Всё верно: это треть ширины сетки в каждой контрольной точке..grid-item {\twidth: 33.3333%;\tpadding-right: 10px;\tpadding-left: 10px;\tfloat: left;}Прежде чем мы двинемся дальше, я хочу вас предостеречь, если вы используете разделенный padding. Если вы взглянете на разметку в CodePen, то увидите, что я добавил дополнительный div внутри .grid-item. Этот дополнительный div важен, если компонент содержит фон или рамки.\tВсё потому, что фон отображается в границах padding. Надеюсь, эта картинка поможет вам разобраться, показав связь между background и другими свойствами.Что бы использовал я?Когда я начинал делать сетки два года назад, я в основном делал сетки, которые были спроектированы по нисходящему подходу и построены на гибридной системе. При таком подходе, я использовал процентные значения и для ширины, и для отступов.В то время, я любил простоту настроек отступов с одной стороны колонки. Это было проще потому, что я не так хорош в математике. От дополнительных рассчётовотступы / 2 я быстро вырубался.Я рад, что я пошёл этим путем. Хоть CSS и выглядит более сложным, чем для разделенных отступов, я был вынужден изучить селектор nth-child. Я также понял важность написания CSS сначала для мобильных. Насколько я могу судить, это до сих пор является главным препятствием и для молодых, и для опытных разработчиков.\tТак или иначе, если вы попросите меня выбрать сейчас, я выберу разделенные отступы вместо односторонних, потому что CSS для них более простой. Также, я рекомендую использовать margin вместо padding, потому что разметка получается чище. Но padding легче рассчитать, поэтому я продолжу статью с ним.Шаг 6: создание отладочной сеткиКогда вы только начинаете, особенно полезно иметь под рукой контрольную сетку, которая поможет отладить вашу разметку. Это помогает быть уверенным, что вы всё делаете правильно.На сегодня, мне известен лишь кривой способ создания отладочной сетки. Нужно создать HTML-разметку и добавить к ней немного CSS. Вот так примерно выглядит HTML:&lt;div class=\"fixed-gutter-grid\"&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;\t&lt;div class=\"column\"&gt;&lt;/div&gt;&lt;/div&gt;CSS для отладочной сетки выглядит следующим образом. Я использую разделенные внешние отступы для упрощения разметки отладочной сетки:.column {\twidth: calc((100% - 20px * 12) / 12);\theight: 80px;\tmargin-right: 10px;\tmargin-left: 10px;\tbackground: rgba(0, 0, 255, 0.25);\tfloat: left;}Шаг 7: внесите изменения в раскладкуСледующий шаг заключается во внесении изменений в раскладку на основе вашего контента. Именно здесь CSS-сетка засияет во всей красе. Вместо того, чтобы создавать разметку с написанием множества сеточных классов, вы можете создать для нее подходящее имя.\tДля примера допустим, что у вас есть сетка для раскладки, которая используется только для гостевых статей. На десктопе раскладка выглядит примерно так:Разметка для раскладки этой гостевой статьи может быть такой:&lt;div class=\"l-guest-article\"&gt;\t&lt;div class=\"l-guest\"&gt;\t\t&lt;!-- Профиль гостя --&gt;\t&lt;/div&gt;\t&lt;div class=\"l-main\"&gt;\t\t&lt;!-- Главная статья --&gt;\t&lt;/div&gt;\t&lt;div class=\"l-sidebar\"&gt;\t\t&lt;!-- Боковые виджеты --&gt;\t&lt;/div&gt;&lt;/div&gt;Итак, сейчас у нас есть 12 колонок. Ширина одной колонки 8,333% (100 / 12).\tШирина .l-guest равна двум колонкам. Поэтому вам нужно умножить 8,333% на два. Достаточно просто. Проделайте тоже самое для остальных элементов.Здесь я предлагаю использовать препроцессор типа Sass, который позволит вам рассчитывать ширину колонок легче, используя функцию percentage, вместо расчетов вручную:.l-guest-article {\t@include clearfix;\t.l-guest {\t\t// Хм, читается лучше, чем 16.666% :)\t\twidth: percentage(2/12);\t\tpadding-left: 10px;\t\tpadding-right: 10px;\t\tfloat: left;\t}\t.l-main {\t\twidth: percentage(7/12);\t\tpadding-right: 10px;\t\tpadding-left: 10px;\t\tfloat: left;\t}\t.l-sidebar {\t\twidth: percentage(3/12);\t\tpadding-right: 10px;\t\tpadding-left: 10px;\t\tfloat: left;\t}}See the Pen Wo by Igor Gorbov (@igorgorbov) on CodePen.Должно быть вы заметили, что сейчас часть кода повторяется. Мы можем это исправить, вынеся общие части кода в отдельный селектор .grid-item..grid-item {\tpadding-left: 10px;\tpadding-right: 10px;\tfloat: left;}.l-guest-article {\t.l-guest {\t\twidth: percentage(2/12);\t}\t.l-main {\t\twidth: percentage(7/12);\t}\t.l-sidebar {\t\twidth: percentage(3/12);\t}}Ну вот, теперь гораздо лучше 🙂Шаг 8: создание вариаций раскладкиПоследний шаг — сделать вашу раскладку адаптивной. Давайте предположим, что раскладка нашей гостевой статьи ведет себя следующим образом:Разметка нашей гостевой статьи не должна меняться. То, что у нас есть — это самая доступная раскладка из возможных. Так что, изменения должны быть полностью в CSS.\tПри написании CSS для нашей адаптивной гостевой раскладки, я настоятельно рекомендую вам писать CSS сначала для мобильных, потому что это делает ваш код проще и аккуратнее. В первую очередь, мы можем начать писать CSS для мобильной раскладки..l-guest-article {\t.l-guest {\t/* Здесь пусто */\t}\t.l-main {\t\tmargin-top: 20px;\t}\t.l-sidebar {\t\tmargin-top: 20px;\t}}Нам здесь нечего делать, каждый компонент занимает всю доступную ширину по умолчанию. Однако мы можем добавить верхний отступ к последним двум элементам, чтобы отделить их друг от друга.\tДалее двигаемся к планшетной раскладке.Давайте предположим, что для этой раскладки мы установим контрольную точку в 700 px. .l-guest должен занимать 4 из 12 колонок, а .l-main и .l-sidebar по 8 колонок каждый.Здесь нам надо удалить свойство margin-top у .l-main, потому что он должен быть на одной линии с .l-guest.\tТакже, если мы установим .l-sidebar ширину 8 колонок, он автоматически перейдет во второй ряд — в первом ряду не хватит места. Поскольку он находится во втором ряду, нам тоже нужно добавить внешний отступ слева у .l-sidebar, чтобы протолкнуть его на позицию. В качестве альтернативы, мы можем сделать его обтекаемым справа — я так и сделаю, это не требует лишних расчётов.И поскольку мы сделали наши грид-элементы обтекаемыми, грид-контейнер должен включать клиар-фикс, чтобы очистить обтекание у дочерних элементов:.l-guest-article {\t@include clearfix;\t.l-guest {\t\t@media (min-width: 700px) {\t\t\twidth: percentage(4/12);\t\t\tfloat: left;\t\t}\t}\t.l-main {\t\tmargin-top: 20px;\t\t@media (min-width: 700px) {\t\t\twidth: percentage(8/12);\t\t\tmargin-top: 0;\t\t\tfloat: left;\t\t}\t}\t.l-sidebar {\t\tmargin-top: 20px;\t\t@media (min-width: 700px) {\t\t\twidth: percentage(8/12);\t\t\tfloat: right;\t\t}\t}}Наконец, давайте перейдем к десктопной раскладке.\tДопустим, для этой раскладки мы установим контрольную точку в 1200 px. .l-guest будет занимать 2 из 12 колонок,.l-main — 7 из 12 и .l-sidebar — 3 из 12.Для этого мы создаем новое медиавыражение в рамках каждого элемента сетки и изменяем ширину по необходимости. Обратите внимание, что мы также должны удалить верхний отступ у .l-sidebar.l-guest-article {\t@include clearfix;\t.l-guest {\t\t@media (min-width: 700px) {\t\t\twidth: percentage(4/12);\t\t\tfloat: left;\t\t}\t\t@media (min-width: 1200px) {\t\t\twidth: percentage(2/12);\t\t}\t}\t.l-main {\t\tmargin-top: 20px;\t\t@media (min-width: 700px) {\t\t\twidth: percentage(8/12);\t\t\tmargin-top: 0;\t\t\tfloat: left;\t\t}\t\t@media (min-width: 1200px) {\t\t\twidth: percentage(7/12);\t\t}\t}\t.l-sidebar {\t\tmargin-top: 20px;\t\t@media (min-width: 700px) {\t\t\twidth: percentage(8/12);\t\t\tfloat: right;\t\t}\t\t@media (min-width: 1200px) {\t\t\twidth: percentage(3/12);\t\t\tmargin-top: 0;\t\t}\t}}See the Pen Wo by Igor Gorbov (@igorgorbov) on CodePen.\tПодводя итогОго. Длинная получилась статья. Я думал, трижды помру, пока писал её. Спасибо, что дочитали до конца. Надеюсь, вы не померли трижды, пока читали! 😛\tКак вы могли заметить, в этой статье шаги для создания адаптивной сетки относительно простые. Большинство путается на шагах 5 (определение положения отступов) и 8 (адаптация раскладки).5-й шаг прост, когда вы учитываете все возможные способы, и мы разобрали их вместе. 8-й шаг проходится легче, если у вас достаточно опыта в написании CSS сначала для мобильных.\tНадеюсь, эта статья дала вам знания для построения вашей собственной адаптивной сетки, и я надеюсь увидеть как вы строите специально созданную сетку для вашего следующего проекта.До скорого!",
        "url": "/blog/html-css/2018-05-14-kak-sozdat-adaptivnuyu-setku.html"
    }
    ,
    
    "blog-javascript-2018-05-13-react-i-es6-chast-4-miksiny-react-ispolzuyushchie-es6-html": {
        "title": "React и ES6 - Часть 4, Миксины React использующие ES6",
            "author": "",
            "category": "",
            "content": "Другие части вы можете найти по ссылкам:            React и ES6 - Часть 1, Введение        React и ES6 - Часть 2, Классы React и инициализаторы свойств ES7        React и ES6 - Часть 3, Биндинг методов в классах React (включая ES7)    При использовании React.createClass() у вас есть возможность использовать так называемые миксины. Они позволяют добавлять некоторую функциональность в ваши компоненты React. Эта концепция не оригинальна, она также используется в Vanilla JS и других языках / фреймворках.Компоненты высшего порядка вместо миксиновМы будем работать с компонентом CartItem из второй части серии.Допустим, вместе с остальными элементами управления, мы хотим отобразить таймер, увеличивающийся каждую секунду.Чтобы лучше проиллюстрировать подход, мы не будем менять код компонента CartItem. Вместо этого, мы создадим некий компонент, который будет оборачивать CartItem и «расширять» его функциональностью. Такие компоненты называются компонентами высшего порядка.Это может звучать загадочно, но все прояснится, когда мы двинемся дальше.    P.S. Под «расширением» я имел в виду простое оборачивание компонента функцией.    Давайте рассмотрим компонент IntervalEnhance:import React from 'react';import { IntervalEnhance } from \"./intervalEnhance\";class CartItem extends React.Component {// component code here}export default IntervalEnhance(CartItem);Пришло время написать компонент IntervalEnhance. Добавьте новый файл intervalEnhance.jsx:import React from 'react';export var IntervalEnhance = ComposedComponent =&gt; class extends React.Component {    static displayName = 'ComponentEnhancedWithIntervalHOC';    constructor(props) {        super(props);        this.state = {            seconds: 0        };    }    componentDidMount() {        this.interval = setInterval(this.tick.bind(this), 1000);    }    componentWillUnmount() {        clearInterval(this.interval);    }    tick() {        this.setState({            seconds: this.state.seconds + 1000         });    }    render() {        return &lt;ComposedComponent {...this.props} {...this.state} /&gt;;    }};Некоторые объяснения.Строка 3. Часть ComposedComponent => class extends React.Component — это то же самое, что определение функции, возвращающей класс. ComposedComponent — это компонент, который мы хотим расширить (в нашем случае CartItem). Используя export var IntervalEnhance мы даем возможность импортировать всю функцию как IntervalEnhance (в коде CartItem выше).Строка 5. Полезна для отладки. Компонент будет называться ComponentEnhancedWithIntervalHOC в React DevTools.Строки 7-12. Мы инициализируем состояние компонента.Строки 14-26. Обработчики жизненного цикла компонента, которые будут запускать и останавливать счетчик для компонента.Строка 29. Самое инетерсное здесь. Эта строка передает все свойства и состояние обертки в компонент CartItem. Благодаря этому мы можем получить доступ к this.state.seconds в компоненте CartItem.Последний шаг — изменить метод render компонента CartItem. Мы выведем this.state.seconds в шаблоне.import React from 'react';import { IntervalEnhance } from \"./intervalEnhance\";class CartItem extends React.Component {    // component code here    render() {        return &lt;article className=\"row large-4\"&gt;                 &lt;!-- some other tags here --&gt;                &lt;p className=\"large-12 column\"&gt;                    &lt;strong&gt;Time elapsed for interval: &lt;/strong&gt;                    {this.props.seconds} ms                &lt;/p&gt;            &lt;/article&gt;;    }}export default IntervalEnhance(CartItem);Откройте страницу в браузере, вы должны увидеть счетчик, изменяющийся каждую секунду:Заметьте — мы все сделали, не изменяя компонент CartItem (за исключением метода render)! Именно поэтому компоненты высшего порядка являются такими мощными.Использование декораторов ES7 вместо миксиновЕсли вам больше нравятся декораторы ES7, их можно использовать похожим способом. Например так:import React from 'react';import { IntervalEnhance } from \"./intervalEnhance\";@IntervalEnhanceexport default class CartItem extends React.Component {    // component code here}Что с PureRenderMixin?Если вы используете миксины, такие как PureRenderMixin, то существуют различные подходы добавить их функциональность в компоненты React, написанные на ES6. Один из них следующий:class Foo extends React.Component {    constructor(props) {        super(props);        this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this);    }    render () {        return &lt;div&gt;Hello&lt;/div&gt;    }}ЗаключениеКомпоненты высшего порядка очень мощные и выразительные. На текущий момент они широко используются и являются заменой старого синтаксиса миксинов. Вы можете создать собственный механизм повторного использования функциональности в компонентах.",
        "url": "/blog/javascript/2018-05-13-react-i-es6-chast-4-miksiny-react-ispolzuyushchie-es6.html"
    }
    ,
    
    "blog-javascript-2018-05-12-react-i-es6-chast-3-binding-metodov-v-klassah-react-html": {
        "title": "React и ES6 - Часть 3, Биндинг методов в классах React",
            "author": "",
            "category": "",
            "content": "Другие части вы можете найти по ссылкам:                        Часть 1, Введение                            Часть 3, Биндинг методов в классах React                            Часть 4, Миксины React использующие ES6            Если вы читали раздел «Метод render компонента CartItem» в предыдущей статье, вас возможно удивило использование this.increaseQty.bind(this).Если мы попытаемся заменить эту конструкцию на {this.increaseQty}, мы увидим ошибку «Uncaught TypeError: Cannot read property ’setState’ of undefined» в консоли:Дело в том, что, когда мы вызываем функцию таким способом, она вызывается не в контексте класса, а значением this является undefined. Это стандартное поведение JavaScript и вполне ожидаемо. В случае использования React.createClass() все методы автоматически связываются с созданным объектом. Это может показаться нелогичным для некоторых разработчиков.Когда команда React реализовывала поддержку ES6, они решили отказаться от автоматического связывания. Давайте рассмотрим различные способы вызова метода в JSX в случае использования ES6 классов.Способ 1. Использование Function.prototype.bind().Мы с ним уже встречались:export default class CartItem extends React.Component {    render() {        &lt;button onClick={this.increaseQty.bind(this)} className=\"button success\"&gt;+&lt;/button&gt;    }}Поскольку любой метод ES6 является обычной функцией JavaScript, он наследует метод bind() прототипа Function. Поэтому теперь, когда мы вызовем increaseQty() в JSX, this будет ссылаться на экземпляр класса. Способ 2. Использование функции, определенной в конструкторе.Этот способ является комбинацией предыдущего способа с использованием конструктора класса:export default class CartItem extends React.Component {    constructor(props) {        super(props);        this.increaseQty = this.increaseQty.bind(this);    }    render() {        &lt;button onClick={this.increaseQty} className=\"button success\"&gt;+&lt;/button&gt;    }}Вам больше не нужно использовать bind() в JSX, но это немного увеличивает код конструктора.Способ 3. Использование стрелочной функции и конструктора.Стрелочные функции ES6 сохраняют контекст выполнения при вызове. Вы можете использовать эту особенность и определить increaseQty() в конструкторе следующим образом:export default class CartItem extends React.Component {    constructor(props) {        super(props);        this.increaseQty = () =&gt; this.increaseQty();    }    render() {        &lt;button onClick={this.increaseQty} className=\"button success\"&gt;+&lt;/button&gt;    }}Способ 4. Использование стрелочных функций и свойств класса ES7.Дополнительно, вы можете использовать стрелочные функции в комбинации с свойствами класса ES7:export default class CartItem extends React.Component {    increaseQty = () =&gt; this.increaseQty();    render() {        &lt;button onClick={this.increaseQty} className=\"button success\"&gt;+&lt;/button&gt;    }}Таким образом, вместо определения метода класса в конструкторе, как в способе 3, мы использовали инициализатор свойства.    Обратите внимание: свойства класса еще не являются частью стандарта JavaScript. Но вы можете пользоваться ими, подключив пресет Babel stage-0. Подробнее об этом можно прочитать в документации Babel.    Мы уже переключались в режим stage 0 во второй части серии, поэтому в данном случае я не буду это объяснять.Способ 5. Использование синтаксиса биндинга ES7.Совсем недавно в Babel реализовали поддержку синтаксического сахара для Function.prototype.bind() с использованием ::. Я не буду вдаваться здесь в подробности о том, как он работает. Уже есть довольно хорошее объяснение. Дополнительную информацию вы можете получить из статьи в    официальном блоге Babel.Ниже показан код с использованием синтаксиса биндинга ES7:export default class CartItem extends React.Component {    constructor(props) {        super(props);        this.increaseQty = ::this.increaseQty;        // line above is an equivalent to this.increaseQty = this.increaseQty.bind(this);    }    render() {        &lt;button onClick={this.increaseQty} className=\"button success\"&gt;+&lt;/button&gt;    }}Эта особенность является экспериментальной.Способ 6. Использование ES7 биндинга в JSX.Вы также можете использовать возможности ES7 биндинга непосредственно в JSX файле. Например:export default class CartItem extends React.Component {    render() {        &lt;button onClick={::this.increaseQty} className=\"button success\"&gt;+&lt;/button&gt;    }}Если кратко, единственным недостатком этого способа является то, что функция пересоздается каждый раз при перерисовке компонента. Это не оптимально. И что более важно, это вызовет проблемы, если вы используете что-то вроде PureRenderMixin (или его эквивалент для классов ES6).ЗаключениеВ той статье мы рассмотрели различные способы биндинга методов класса в компонентах React. В следующий раз мы рассмотрим, как обстоят дела с миксинами React в ES6 классах.",
        "url": "/blog/javascript/2018-05-12-react-i-es6-chast-3-binding-metodov-v-klassah-react.html"
    }
    ,
    
    "blog-javascript-2018-05-11-react-i-es6-chast-2-klassy-react-i-inicializatory-svoystv-es7-html": {
        "title": "React и ES6 - Часть 2, Классы React и инициализаторы свойств ES7",
            "author": "",
            "category": "",
            "content": "Другие части вы можете найти по ссылкам:                        Часть 1, Введение                            Часть 2, Классы React и инициализаторы свойств ES7                            Часть 4, Миксины React использующие ES6            В первой статье мы начали с введения в ES6 и создания статичного компонента React, выводящего «Hello from ES6». Не очень интересно :)В этой статье мы собираемся создать немного более сложный компонент React CartItem. Он будет выводить информацию о продукте, включая изображение, заголовок и цену. Также пользователь сможет взаимодействовать с компонентом CartItem, увеличивая или уменьшая количество элементов.Наш компонент будет изменять при этом общую сумму.Вот что мы увидим в результате:Создание файла index.htmlНачнем с создания простого HTML-файла:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;React and ES6 Part 2&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/css/foundation.min.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"root\"&gt;&lt;/div&gt;&lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Обратите внимание, что мы подключили фреймворк Foundation CSS с CDN. Это сделает наше приложение немного более симпотичным. Элемент div.root будет использоваться как контейнер для React приложения.Gulpfile.jsПросто скопируйте содержимое gulpfile.js из предыдущей части. Никаких изменений на данном этапе не понадобиться.Также скопируйте package.json. Далее, запустите команду npm install (чтобы установить зависимости) и затем команду gulp. Gulp будет непрерывно следить за изменениями в файлахОсновной компонент приложенияСоздайте app.jsx:import React from 'react';import CartItem from './cartItem';const order = {    title: 'Fresh fruits package',    image: 'http://images.all-free-download.com/images/graphiclarge/citrus_fruit_184416.jpg',    initialQty: 3,    price: 8};React.render(    &lt;CartItem title={order.title}          image={order.image}          initialQty={order.initialQty}          price={order.price}/&gt;,    document.querySelector('.root')    );Вот что здесь происходит:            Строка 1. Мы импортируем библиотеку React и инициализируем переменную React.                Строка 2. Импортируем компонент CartItem, мы создадим его позже.                Строки 4-9. Передаем свойства в компонент CartItem (включая заголовок товара, изображение, начальную стоимость и цену).                Строки 11-17. Монтируем компонент CartItem в элемент DOM по классу .root.            Структура компонента CartItemПришло время создать компонент, отвечающий за отображение данных и взаимодействие с пользователем.    Добавьте следующий код в файл cartItem.jsx:import React from 'react';export default class CartItem extends React.Component {    constructor(props) {    super(props);    this.state = {        qty: props.initialQty,        total: 0    };}    componentWillMount() {        this.recalculateTotal();    }    increaseQty() {        this.setState({qty: this.state.qty + 1}, this.recalculateTotal);    }    decreaseQty() {        let newQty = this.state.qty &gt; 0 ? this.state.qty - 1 : 0;        this.setState({qty: newQty}, this.recalculateTotal);    }    recalculateTotal() {        this.setState({total: this.state.qty * this.props.price});    }}Объяснение:                        Строки 4-10. Это конструктор, появившийся в классах React. Первое, на что следует обратить внимание — это вызов функции super(props), он является обязательным. Следующий момент — вместо метода getInitialState(), разработчики React рекомендуют использовать своство this.state. Мы инициализировали состояние свойствами, переданными из app.jsx. Лично мне нравится это улучшение.                            Строки 11-13. Объявление метода componentWillMount() (который в конечном счете является методом класса CartItem). В этом методе мы длаем пересчет общей стоимости. Чтобы рассчитать общую стоимость, мы используем метод recalculatePrice(), который умножает количество (хранится в состоянии компонента) на цену (является свойством).                            Строки 14-20. Методы для увеличения или уменьшения количества элементов. Эти методы будут вызываться по нажатию на кнопки (см. скриншот приложения в начале статьи). Также обратите внимание, что мы используем в качестве функции обратного вызова метода this.setState() метод пересчета общей стоимости.            Метод render компонента CartItemМетод render компонента CartItemexport default class CartItem extends React.Component {// previous code we wrote hererender() {    return &lt;article className=\"row large-4\"&gt;        &lt;figure className=\"text-center\"&gt;            &lt;p&gt;                &lt;img src={this.state.image}/&gt;            &lt;/p&gt;            &lt;figcaption&gt;                &lt;h2&gt;{this.state.title}&lt;/h2&gt;            &lt;/figcaption&gt;        &lt;/figure&gt;        &lt;p className=\"large-4 column\"&gt;&lt;strong&gt;Quantity: {this.state.qty}&lt;/strong&gt;&lt;/p&gt;        &lt;p className=\"large-4 column\"&gt;            &lt;button onClick={this.increaseQty.bind(this)} className=\"button success\"&gt;+&lt;/button&gt;            &lt;button onClick={this.decreaseQty.bind(this)} className=\"button alert\"&gt;-&lt;/button&gt;        &lt;/p&gt;        &lt;p className=\"large-4 column\"&gt;&lt;strong&gt;Price per item:&lt;/strong&gt; ${this.state.price}&lt;/p&gt;        &lt;h3 className=\"large-12 column text-center\"&gt;            Total: ${this.state.total}        &lt;/h3&gt;        &lt;/article&gt;;    }}    Здесь мы используем только теги в формате JSX + состояние компонента и применяем Foundation CSS для декорирования.    Не беспокойтесь по поводу {this.increaseQty.bind(this)} — я объясню это в следующей статье серии. А пока просто поверьте мне, что эта строка будет вызывать метод increaseQty() класса CartItem.    Итак, теперь у нас симпотичное приложение, взаимодействующее с пользователем. Не смотря на то, что это простой пример, он показывает, как написать компонент React, используя ECMAScript 6. Лично мне нравится новый синтаксис ES6.    Мы еще не закончили. Перед тем, как закончить статью, я хотел бы взглянуть на пару дополнительных функций ES6.Default Props и Prop Types в ES6 классах ReactПредставьте, что мы хотим добавить валидацию и значения по умолчанию для компонета CartItem.    К счастью, это поддерживается React и называется Default Props и Prop Types.    После класса CartItem добавьте следующие строки:CartItem.propTypes = {    title: React.PropTypes.string.isRequired,    price: React.PropTypes.number.isRequired,    initialQty: React.PropTypes.number};CartItem.defaultProps = {    title: 'Undefined Product',    price: 100,    initialQty: 0};В результате, если вы попытаетесь передать число в качестве свойства title, вы получите предупреждение в консоли. В этом сила валидации свойств React.Добавление ES7 в проектВы можете задать вполне резонный вопрос — зачем я буду думать о ES7, когда ES6 только стандартизирован?    Я отвечу, что это взгляд в будущее. И начало использования таких особенностей, как инициализаторы свойств и декораторы.    Несмотря на то, что ES7 пока находится на совсем ранней стадии, есть ряд особенностей, которые уже реализованы в Babel. Эти экспериментальные особенности транслируются с ES7 в валидный ES5. Круто!    Чтобы добавить синтаксический сахар, нам необходимо внести небольшое изменение в строку 8 в gulpfile.js. Замените эту строку на код ниже:.transform(babelify.configure({stage: 0}))Инициализаторы свойств ES7 для Default Props и Prop Types компонента ReactВ класс CartItem добавьте следующий код перед конструктором:export default class CartItem extends React.Component {    static propTypes = {        title: React.PropTypes.string.isRequired,        price: React.PropTypes.number.isRequired,        initialQty: React.PropTypes.number    };    static defaultProps = {        title: 'Undefined Product',        price: 100,        initialQty: 0    };    constructor() {    ...    }    // .. all other code}Инициализаторы свойств ES7 для начального состояния компонентаФинальным шагом будет перенос начального состояния компонента из конструктора в инициализатор свойства.    Добавьте следующий код перед конструктором класса CartItem:export default class CartItem extends React.Component {    // .. some code here    state = {        qty: this.props.initialQty,        total: 0    };    // .. constructor starts hereВы можете удалить код, связанный с инициализацией начального состояния, из конструктора.ЗаключениеВ этой статье мы познакомились с реализацией компонентов React на ES6, а также кратко рассмотрели инициализаторы свойств ES7. Следите за серией ES6 + React!",
        "url": "/blog/javascript/2018-05-11-react-i-es6-chast-2-klassy-react-i-inicializatory-svoystv-es7.html"
    }
    ,
    
    "blog-javascript-2018-05-11-react-i-es6-chast-1-vvedenie-html": {
        "title": "React и ES6 - Часть 1, Введение",
            "author": "",
            "category": "",
            "content": "Другие части вы можете найти по ссылкам:                        Часть 2, Классы React и инициализаторы свойств ES7                            Часть 3, Биндинг методов в классах React                            Часть 4, Миксины React использующие ES6            В версии ReactJS v0.13.0 Beta 1 появилась совместимость ECMAScript 6 с компонентами React. Какие преимущества это дало разработчикам?Что ж, ECMAScript 6 (или ECMAScript 2015) — это новый стандарт JavaScript, принесший множество новых особенностей в мир JavaScript. Таких как классы, стрелочные функции, rest параметры, итераторы, генераторы и многое, многое другое.Это здорово, но вгляните на таблицу совместимости ES6. Выглядит так, будто пройдут годы, пока мы сможем использовать ES6 в браузере (помните ситуацию с поддержкой ES5?).К счастью, это не совсем так. Вам не придется ждать, пока разработчики браузеров реализуют поддержку ECMAScript 6 в браузерах. Существуют инструменты, называемые трансляторами, конвертирующие код, написанный на ES6, в ES5-совместимый код. Аналогично тому, как CoffeeScript транслируется в JavaScript.Одно из таких решений называется Babel, действительно удивительный инструмент. Большое спасибо разработчикам. Что хорошо, Babel поддерживает огромное число различных фреймворков, систем сборки, тестовых фреймворков, шаблонизаторов —    посмотрите здесь.Чтобы получить краткое представление о том, как работает Babel, рассмотрим пример. Скажем, у нас есть следующий код:var evenNumbers = numbers.filter((num) =&gt; num % 2 === 0);После запуска Babel получим следующий код:var evenNumbers = numbers.filter(function (num) {    return num % 2 === 0;});Аналогичные манипуляции применяются и к другим конструкциям ES6.Подготовка окружения разработкиДля того, чтобы настроить неперерывную работу Babel, мы будем использовать Gulp. Это сборщик основан на node.js и может упростить вам жизнь, автоматизируя рутинные задачи. Если вы слышали о Grunt, то Gulp — это почти то же самое.    Очевидно, вам понадобится Node.js. Установите его в вашей системе, если он еще не установлен.            Далее, вам нужно установить Gulp глобально: npm install -g gulp.        Перейдите в директорию с проектом. Инициализируйте файл package.json с помощью команды npm init.            Запустите команду npm install --save react@0.13.x. Эта команда установит react в директорию node_modules и сохранит в качестве зависимости в package.json.            Запустите команду npm install --save-dev gulp browserify babelify vinyl-source-stream babel-preset-es2015 babel-preset-react. Эта команда установит зависимости разработки.Создание gulpfile.jsСоздайте файл gulpfile.js в корневой директории проекта со следующим содержимым:var gulp = require('gulp');var browserify = require('browserify');var babelify = require('babelify');var source = require('vinyl-source-stream');gulp.task('build', function () {    return browserify({entries: './app.jsx', extensions: ['.jsx'], debug: true})        .transform('babelify', {presets: ['es2015', 'react']})        .bundle()        .pipe(source('bundle.js'))        .pipe(gulp.dest('dist'));});gulp.task('watch', ['build'], function () {    gulp.watch('*.jsx', ['build']);});gulp.task('default', ['watch']);});Надеюсь, некоторые объяснения будут полезны.Строки 1-4. Мы подключаем необходимые node.js модули и инициализируем соответствующие переменные.Строка 6. Объявляем задачу gulp с именем build, которая будет запускаться по команде gulp build.Строка 7. Начинаем описывать, что должна делать команда. Мы говорим Gulp, что нужно использовать Browserify для app.jsx. В дополнение, мы включили режим отладки, который будет полезен при разработке.Строки 8-11. Мы добавили трансформацию с помощью Babelify. Это позволит сконвертировать код на ECMAScript 6 в ECMAScript 5. Результат будем выводить в файл dist/bundle.js. Также мы подключили необходимые пресеты Babel.Строки 14-16. Мы определили задачу с именем watch, которую будем запускать по команде gulp watch. Эта задача будет запускать gulp build при каждом изменении jsx файлов.Строка 18. Мы определили задачу gulp, которая будет запускаться по команде gulp. Эта команда просто выполняет задачу watch.Теперь ваш воркфлоу будет состоять из ввода команды gulp и нажатия клавиши Enter. Сборщик будет наблюдать за изменениями в компонентах React и пересобирать файлы непрерывно.JSX и BabelВы, возможно, уже заметили, что мы использовали расширение .jsx вместо .js. JSX — это расширение синтаксиса JavaScript, разработанное командой ReactJS. Этот формат используется для упрощения написания компонентов ReactJS.Первый компонент React на ECMAScript 6Пришло время создать наш первый очень простой компонент на ES6. Добавим файл с именем Hello-world.jsx в корень проекта:import React from 'react';class HelloWorld extends React.Component {    render() {        return &lt;h1&gt;Hello from {this.props.phrase}!&lt;/h1&gt;;    }}export default HelloWorld;Некоторые объяснения:    Строка 1. Мы подключаем библиотеку React и инициализируем переменную React.        Строки 3-8. Для создания компонента React используем класс ES6, наследующий от класса React.Component. Мы добавили простой метод render, выводящий тег h1, содержащий свойство phrase.        Строка 9. Экспортируем созданный компонент с помощью export default HelloWorld.    Чтобы упростить понимание, я добавил код такого же компонента, но написанного без использования ES6 классов:import React from 'react';var HelloWorld = React.createClass({    render: function() {        return (            &lt;h1&gt;Hello from {this.props.phrase}!&lt;/h1&gt;        );    }});export default HelloWorld;ОберткаЗавершим наш простой пример. Создайте файл с имененм app.jsx:import React from 'react';import HelloWorld from './hello-world';React.render(    &lt;HelloWorld phrase=\"ES6\"/&gt;,    document.body);Мы импортируем компонент HelloWorld, созданный на предыдущем шаге и передаем свойство phrase.Далее, создайте файл index.html:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;ReactJS and ES6&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Теперь запустите команду gulp в терминале (она создаст файл dist/bundle.js) и откройте HTML файл в браузере.    Вы должны увидеть то же, что на изображении ниже.",
        "url": "/blog/javascript/2018-05-11-react-i-es6-chast-1-vvedenie.html"
    }
    ,
    
    "blog-javascript-2018-05-10-obeshchanie-burgernoy-vecherinki-html": {
        "title": "Обещание бургерной вечеринки",
            "author": "",
            "category": "",
            "content": "    Перевод статьи «The Promise of a Burger Party» Марико Косаки.Я написала этот пост как альтернативное введение в JavaScript-промисы. Я набросала его в своем блокноте во время чтения многочисленных статей на эту тему. Если вам нужно более глубокое руководство, в конце статьи есть список для дальнейшего изучения.Пару недель назад я участвовала в обсуждении кое-какой функциональности на JavaScript. Она должна была работать асинхронно с использованием внешних данных. Я сказала: «ладно, давайте используем fetch()… тогда в коде это… эм-м…» И пока я молчала, пытаясь вспомнить API Fetch, мой собеседник сказал: «он возвращает промис». Я впала в ступор и ответила: «честно говоря, я не очень понимаю, что это значит…»Я множество раз писала код на основе промисов, но в этот раз части почему-то не сложились в единую картину. Я поняла, что в действительности так и не разобралась с нимиЕсли вы читаете меня в Twitter, то знаете, что я учусь на визуальных примерах: беру объекты реального мира как метафоры для сложных концепций в коде и изображаю их в виде рисунков. Это позволяет мне совладать с двойным уровнем абстракции: языком программирования и английского как неродного языка. В общем, мне пришлось рисовать и в этот раз.А вот пример кода, с которым мы будем иметь дело в этой истории.// Асинхронная операцияfunction cookBurger (type) { ... }// Обычная операцияfunction makeMilkshake (type) { ... }// Функция оформления заказа, возвращает промисfunction order (type) {   return new Promise(function(resolve, reject) {      var burger = cookBurger(type)      burger.ready = function (err, burger) {         if (err) {            return reject(Error('Error while cooking'))         }         return resolve(burger)      }   })}order('JakeBurger')   .then( burger => {      const milkshake = makeMilkshake('vanila')      return { burger: burger, shake: milkshake }   })   .then( foodItems => {      console.log('BURGER PARTY !', foodItems)   })   .catch( err => {     console.log(err)   })Устроим бургерную вечеринку!Добро пожаловать в парк Промис-Сквер, место встречи всех любителей бургеров — кафе «ДжейкШак». Бургеры ДжейкШака очень популярны в окру́ге, но в кафе мало кассовых аппаратов, и очередь из посетителей никогда не убывает. Несмотря на это, на кухне хватает рук, чтобы принимать множество заказов одновременно.Если вы не в курсе: кафе ShakeShak в парке Мэдисон-Сквер — это место в Нью-Йорке. Кафе действительно отличное, но туда всегда длинная очередь .Пообещать сделатьЧтобы принимать заказы максимально быстро, ДжейкШак использует систему сигнальных брелков. После оплаты заказа на кассе, сотрудник кафе выдает посетителю поднос и такой брелок.Поднос — это промис, обещание ДжейкШака преподнести вам вкуснейший бургер, как только тот будет готов, а брелок — индикатор состояния вашего заказа. Брелок молчит? — значит заказ в процессе и лучшие повара трудятся над вашим бургером. Брелок загорелся красным и гудит? — значит заказ приготовлен.Но есть небольшой нюанс: «приготовлен» — не значит «готов». Это значит, что работа поваров над заказом завершена, и они хотят, чтобы вы подошли и забрали его. Вы как клиент, вероятно, хотите просто получить свой бургер, но, в некоторых случаях, предпочтёте уйти. Дело ваше.Давайте посмотрим, как это работает в коде. Когда вы вызываете функцию order (делаете заказ), она возвращает promise (выдает поднос и брелок как обещание выполнить заказ). Возвращённое значение (бургер) должен появиться на подносе, когда будет исполнен промис (данное вам обещание) и сработал колбэк. Подробнее об этом в следующем разделе!Добавьте обработчики промисовОй, кажется брелок загудел. Пойдемте за стойку попросим заказ. На этом этапе возможны два сценария развития событий.1. Заказ исполненУра-а! Ваш заказ готов, сотрудник кафе выносит свежий ароматный бургер. Обещание приготовить отличный бургер можно считать выполненным.2. Заказ отклоненПохоже, на кухне закончились котлеты. Обещание приготовить бургер выполнено не будет, оно отменяется. Не забудьте потребовать назад ваши деньги!Посмотрим, как мы можем подготовиться к этим двум ситуациям в нашем коде.Метод .then() принимает вторым аргументом функцию. Эта функция является обработчиком для reject. Но для простоты в своем примере я буду использовать для обработки ошибок только .catch().Связываем промисыСкажем, ваш заказ был успешно выполнен, но тут вы вспоминаете, что для фееричной бургерной вечеринки вам не хватает молочного коктейля… и вы идете в очередь «С» (специальная очередь за напитками, существует в ShakeShack на самом деле, чтобы справиться с наплывом посетителей). При заказе коктейля кассир вручает вам другой поднос и еще один брелок. Так как напитки готовятся быстро, кассир сам выдает заказ, и не нужно ждать, когда загудит брелок (он уже гудит!).Посмотрим, как это работает в коде. Чтобы соединить промисы в цепочку, достаточно всего лишь добавить еще один then(), он всегда возвращает промис. Просто запомните: каждый .then() возвращает поднос и брелок, а текущее возвращаемое значение передается аргументом в коллбэк.Другие трюки для вечеринок!У промисов есть и другие методы, которые позволяют делать классные трюки. Promise.all() создает промис, принимающий массив промисов (items). Он исполняется, когда исполнены все элементы массива, каждый из которых тоже промис. Представим это так: вы заказали для друзей пять бургеров, но не хотите все пять раз бегать к стойке. Достаточно сделать это один раз, когда все бургеры будут готовы. Promise.all() в этом случае — отличное решение.Promise.race() похож на Promise.all(), но исполнится или будет отклонен, как только будет исполнен или отклонен один из элементов массива промисов. Своего рода принцип «хватай и беги». Скажем, вы очень голодны и заказали бургер, чизбургер и хотдог одновременно, но заберёте только то, что быстрее приготовят. Обратите внимание, в этом случае, если на кухне закончились котлеты для бургеров, и отказ по бургеру вернется первым, то и все прочие заказы будут отменены.Помимо этого, в JavaScript-промисах есть много других вещей для изучения. ",
        "url": "/blog/javascript/2018-05-10-obeshchanie-burgernoy-vecherinki.html"
    }
    ,
    
    "blog-other-2018-05-09-besplatnyy-sayt-na-github-pages-pri-pomoshchi-jekyll-html": {
        "title": "Cайт на GitHub Pages при помощи Jekyll",
            "author": "",
            "category": "",
            "content": "    Jekyll — генератор статических сайтов. Это означает, что на вход ему даётся какая-либо информация, а на выходе получается набор HTML-страничек. Всё отлично когда сайт простой или даже одностраничный.Быстрый стартВ Jekyll есть готовые шаблоны. Выполните:jekyll new testБудет создан новый сайт в директории test. Этот сайт уже готов к работе, так что можно прямо сейчас его запустить.cd test/jekyll serve -H $IP -P $PORT --baseurl \"\"Структура сайтаСгенерированные файлы в директории test имеют такую структуру:- В папке _posts расположены статьи в формате Markdown. Мы сами должны добавлять сюда свои статьи, после чего Jekyll сгенерирует из них html-страницы и обновит индекс сайта.- В папке _site хранятся сгенерированные страницы. Редактировать, добавлять или удалять файлы здесь не стоит, все изменения при пересборке будут потеряны.- about.md и index.md — дополнительные страницы. Мы можем добавить нужные страницы, тем самым воссоздав желаемую структуру сайта. Например, можно создать файл contacts.md, где разместить контакты для обратной связи. Вместо файлов Markdown здесь можно добавлять и обычные html-страницы.- _config.yml — файл конфигурации сайта. Здесь можно добавить какие-нибудь плагины, задать переменные, которые затем будут использоваться в шаблонах и т.д.Содержимое _config.ymltitle: Your awesome titleemail: your-email@domain.comdescription: > # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this  line in _config.yml. It will appear in your document head meta (for  Google search results) and in your feed.xml site description.baseurl: \"\" # the subpath of your site, e.g. /blogurl: \"\" # the base hostname & protocol for your site, e.g. http://example.comtwitter_username: jekyllrbgithub_username:  jekyll# Build settingsmarkdown: kramdowntheme: minimagems:  - jekyll-feedexclude:  - Gemfile  - Gemfile.lockКак работает JekyllJekyll — статический генератор сайтов. Вы подаёте ему какие-то файлы, он их парсит, берёт мета-информацию, если таковая имеется, подставляет вместо переменных какие-либо значения, при необходимости подключает содержимое других файлов и в итоге генеририрует файлы html в нужной структуре. Тем самым получается готовый сайт, который можно открыть как локально, так и разместив у себя на сайте, на GitHub Pages или любом другом хранилище.Чтобы указать, что файл нужно интерпретировать, необходимо в самом начале добавить код, именуемый «YAML front mat­ter»:------Содержимое файлаМежду тройными дефисами можно указывать мета-информацию. Для примера заглянем в тот Markdown-файл из папки _posts, который сгенерировался по умолчанию.---layout: posttitle:  \"Welcome to Jekyll!\"date:   2018-04-12 09:36:51 +0000categories: jekyll update---You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes.Jekyll возьмёт при сборке эту мета-информацию и у статьи будет название Welcome to Jekyll!, датой её публикации будет 2018-04-12 09:36:51, а относиться статья будет к категории jekyll update.Разметки (layouts)По умолчанию для статей используется разметка post, мы сами указываем её в заголовке статьи:---layout: posttitle:  \"Welcome to Jekyll!\"...---ПеременныеВсё, что мы указываем в мета-информации поста, попадает в переменную post.    Например, создадим новый код, файл 2018-04-12-easy-rss.md:---layout: codetitle: \"EasyRss\"date: 2018-04-12 13:22:08 +0000categories: javatags: [java, rss]author: username---includeinclude подключает содержимое файла в указанное место на странице.Например, виджет шаринга от Яндекса можно вынести в отдельный    файл _includes/share.html, тогда в _layouts/code.html вместо длинного div можно будет написать:&#123;% include share.html %}Публикация в GitHub PagesДля первого вида нужно создать репозиторий с именем: \"ваш-ник.github.io\".    Второй же вид можно задействовать для любого своего репозитория. Достаточно в настройках проекта включить поддержку GitHub Pages и залить сайт в ветку gh-pages или папку docs.Я же воспользуюсь первым типом.Надеюсь, эта статья поможет вам создать свой собственный сайт или блог.",
        "url": "/blog/other/2018-05-09-besplatnyy-sayt-na-github-pages-pri-pomoshchi-jekyll.html"
    }
    ,
    
    "blog-javascript-2018-05-08-javascript-promise-html": {
        "title": "Обещания (promises) в JavaScript",
            "author": "",
            "category": "",
            "content": "Обещания (promises) — это объекты, позволяющие упорядочить выполнение асинхронных вызовов.Асинхронный вызов — это вызов функции, при котором выполнение основного потока кода не дожидается завершения вызова. Например, выполнение http-запроса не прерывает выполнение основного потока. То есть выполняется запрос, и сразу, не дожидаясь его завершения, выполняется код следующий за этим вызовом, а результат http-запроса обрабатывается после его завершения функцией обратного вызова (callback-функцией).Далее будем последовательно разбираться с функционированием обещаний. Пока будем исходить из того, что у нас уже есть объект-обещание выполнить некий асинхронный вызов. О том, откуда берутся обещания и, как их сформировать самому, поговорим чуть позже.1. Обещания предоставляют механизм, позволяющий управлять последовательностью асинхронных вызовов. Иными словами, обещание — это просто обертка над асинхронным вызовом. Обещание может разрешиться успешно или завершиться с ошибкой. Суть механизма в следующем. Каждое обещание предоставляет две функции: then() и catch(). В качестве аргумента в каждую из функций передается функция обратного вызова. Callback-функция в then вызывается в случае успешного разрешения обещания, а в catch — в случае ошибки:promise.then(function(result){  // Вызывается после успешного разрешения обещания}).catch(function(error){  // Вызывается в случае ошибки});2. Следующий момент, который нужно уяснить. Обещание разрешается только один раз. Иными словами асинхронный вызов, который происходит внутри обещания выполняется только один раз. В дальнейшем обещание просто возвращает сохраненный результат асинхронного вызова, больше его не выполняя. Например, если мы имеем некоторое обещание promise, то:  // Первое разрешение обещанияpromise.then(function(result){  // При разрешении обещания происходит асинхронный вызов,  // результат которого передается в эту функцию});// Повторное разрешение того же обещанияpromise.then(function(result){  // Теперь уже асинхронный вызов не выполняется.  // В эту функцию передается сохраненный результат  // разрешения обещания});3. Функции then() и catch() возвращают обещания. Таким образом, можно выстраивать цепочки обещаний. При этом результат, который возвращает callback-функция в then(), передается в качестве аргумента на вход callback-функции последующего then(). А аргумент вызова throw(message) передается в качестве аргумента callback-функции в catch():  promise.then(function(result){  // Обработка разрешения обещания (код пропущен)  return result1; // Возвращаем результат обработки обещания}).then(function(result){  // Аргумент result в этой функции имеет значение result1,  // переданный из предыдущего вызова  if(condition){    throw(\"Error message\");  }}).catch(function(error){  // Если в предыдущем вызове условие выполнится,  // то сработает исключение, управление будет передано в эту  // функцию и переменная error будет иметь значение \"Error message\"});4. В качестве результата callback-функция в then() может возвращать не только какое-либо значение, но и другое обещание. При этом в следующий вызов then() будет передан результат разрешения этого обещания:  promise1.then(function(result1){  return promise2.then(function(result2){    // Какие-то действия    return result3;  });}).then(function(result){  // Значение аргумента result в этой функции будет равно result3}).catch(function(error){  // Обработка ошибок});5. Можно то же самое сделать, выстроив разрешение обещаний в одну линейную цепочку без вложений:  promise1.then(function(result1){  return promise2;}).then(function(result2){  // Какие-то действия  return result3;}).then(function(result){  // Значение аргумента result в этой функции будет равно result3}).catch(function(error){  // Обработка ошибок});Обратите внимание на то, что каждая цепочка обещаний заканчивается вызовом catch(). Если этого не делать, то возникающие ошибки будут пропадать в недрах обещаний и, тогда невозможно будет установить, где произошла ошибка.Подводим итогЕсли необходимо выполнить последовательность асинхронных вызовов (то есть, когда каждый следующий вызов должен выполниться строго после завершения предыдущего), то эти асинхронные вызовы необходимо выстроить в цепочку обещанийОткуда берутся обещанияОбещания можно получить двумя способами: либо функции используемой библиотеки могут возвращать готовые обещания, либо можно самостоятельно оборачивать в обещания асинхронные вызовы функций, не поддерживающих обещания (промисификация). Рассмотрим каждый вариант отдельно.Обещания библиотечных функцийМногие современные библиотеки поддерживают работу с обещаниями. О том, поддерживает библиотека обещания или нет, можно узнать из документации. Некоторые библиотеки поддерживают оба варианта работы с асинхронными вызовами: функции обратного вызова и обещания.Чтобы запустить параллельное выполнение нескольких независимых действий нужно использовать вызов:  Promise.all([  promise_1,  promise_2,  ...,  promise_n]).then(function(results){  // Какие-то действия после завершения});То есть, на вход функции Promise.all передается массив обещаний. Все обещания в этом случае запускаются на выполнение сразу. Функция Promise.all возвращает обещание выполнить все обещания, поэтому вызов then() в этом случае срабатывает после выполнения всех обещаний массива. Параметр results, который передается на вход функции в then(), является массивом результатов работы обещаний в той последовательности, в которой они передавались на вход Promise.all.Выстраивание цепочки обещаний в цикле forПредположим, что некая функция doSomething() возвращает обещание выполнить какое-то асинхронное действие, и нам надо выполнить это действие последовательно n раз. Пусть само обещание возвращает некий строковый результат result, который используется при следующем асинхронном вызове. Также допустим, что первый вызов делается с пустой строкой. В этом случае выстраивание цепочки обещаний делается так:  // Устанавливаем начальное значение цепочки обещанийvar actionsChain = Promise.resolve(\"\");// В цикле составляем цепочку обещанийfor(var i = 0; i Пример использования обещанийВ качестве более сложного примера применения обещаний рассмотрим фрагмент кода сервиса генерации уникальных идентификаторов. Суть работы сервиса очень проста: на каждый запрос GET к сервису он вычисляет и возвращает очередной уникальный идентификатор. Однако, учитывая то, что одновременно к сервису может быть направлено несколько конкурирующих запросов, возникает задача выстраивания этих запросов в очередь (цепочку) обещаний для последующего выполненияКод самого сервера выглядит так:  // Создаем HTTP-серверvar server = http.createServer(processRequest);// Перед остановкой сервера закрываем соединение с redisserver.on('close', function(){  storage.quit();});// Запускаем серверserver.listen(config.port, config.host);console.log('Service is listening '+config.host+':'+config.port);Это стандартный код http-сервера, написанного на node.js. Функция processRequest — обработчик http-запроса. Сам сервис использует для хранения своего состояния хранилище redis. Механизм сохранения состояния в redis не имеет значения для понимания данного примера, поэтому рассматриваться не будет. Но при завершении работы сервера нам необходимо закрыть соединение с redis, что и отражено в коде выше. Важно только следующее: при каждом запросе вызывается функция processRequest. Очередь запросов представляет собой обещание requestQueue. Рассмотрим теперь сам код:Для вычисления самого идентификатора используется функция calcUUID(), которая возвращает обещание вычислить уникальный идентификатор. Код этой функции рассматривать не будем, так как для понимания этого примера он не нужен. При получении запроса к очереди обработки добавляется обещание вычислить очередной идентификатор. Таким образом, несколько конкурирующих запросов выстраиваются в одну цепочку, где вычисление каждого следующего идентификатора начинается после вычисления предыдущего.ЗаключениеТаким образом, обещания позволяют контролировать процесс выполнения асинхронных вызовов, делая при этом код читаемым и доступным для понимания. Необходимо только научиться использовать механизмы обещаний и шаблоны программирования с использованием обещаний.",
        "url": "/blog/javascript/2018-05-08-javascript-promise.html"
    }
    ,
    
    "blog-other-2018-01-20-novaya-kamera-dlya-raspberry-pi-html": {
        "title": "Вскоре выйдет новая камера для Raspberry Pi, которая будет стоить $25",
            "author": "",
            "category": "",
            "content": "Энтузиасты other до недавнего времени вынуждены были использовать для своих проектов далеко не лучшую камеру. Официально предлагаемое Raspberry Pi решение было выпущено еще в 2013 году и обладало разрешением 5 Мп с датчиком OmniVision OV5647.Камера стоила $25 и не могла похвастаться хорошим качеством снимков и видео. 25 апреля 2016 года разработчики наконец-то представили обновленный продукт, получивший 8 Мп датчик.\tПервая версия камеры Raspberry Pi была снята с производства еще в 2014 году, но за этим модулем до сих пор охотятся пользователи, ведь камеры используются во множестве проектов: телескопы, научные проекты, воздушные змеи для картографирования.В официальном блоге разработчики Raspberry Pi пишут, что им давно известно об этой проблеме, поэтому other-сообществу представили новую камеру. Новинка тоже не относится к разряду флагманских решений, однако она в любом случае лучше 5-мегапиксельной версии, которую к тому же сложно купить. Модуль камеры базируется на датчике Sony IMX219, обладает разрешением 8 Мп и по-прежнему будет стоить $25.На сайте Sony можно найти информацию об этом датчике, датированную 2014 годом. Так, камера обладает фиксированной фокусировкой, может осуществлять съемку фото с разрешением 3280 x 2464 пикселей, а также съемку HD видео.Новинка должна поступить в продажу уже в ближайшее время.",
        "url": "/blog/other/2018-01-20-novaya-kamera-dlya-raspberry-pi.html"
    }
    ,
    
    "blog-design-2018-01-20-10-udobnyh-reshenij-dlya-ispolzovaniya-plansheta-html": {
        "title": "10 удобных решений, хитростей и приемов для использования планшета",
            "author": "",
            "category": "",
            "content": "Жизнь без гаджетов уже невозможно представить. Их возможности велики, но можно сделать девайсы еще более удобными. 10 лайфхаков помогут приручить самый строптивый планшет и направят все его ресурсы в русло пользы.1. Из всех искусств для нас важнейшим является… кулинарияПроснулся поварской талант? Планшет с книгой рецептов в руки и готовим! А чтобы не заляпать девайс, повесьте его с помощью чехла на вешалку, а вешалку – на ручку шкафчика. Для надежности скрепите конструкцию канцелярской резинкой или прищепками.2. Усиливаем звук динамикаС планшетом кинокомнату не устроишь. И дело даже не в размере картинки. Приятному просмотру препятствует тихий звук. Увеличить его можно с помощью пластикового стаканчика. Прорежьте в нем отверстие, насадите стаканчик на угол с динамиком – и ловите вполне себе сносный звук.3. Подсвечиваем объект фотографированияХорошее фото требует правильного света. Фотографируя предмет, подсветите его с двух сторон планшетами, выбрав на них любое приложение с белым фоном и увеличив яркость до максимума. Качество такого снимка будет на порядок выше ваших предыдущих попыток.4. Ставим планшет на устойчивую опоруИногда хочется удобно расположиться на диване, поставить планшет рядом и посмотреть хороший фильм. Увы, на мягкой поверхности подставка из чехла неустойчива. Планшет падает от любого телодвижения. Линейка, прикрепленная к треугольнику чехла прищепками, в корне изменит ситуацию и обеспечит планшету надежную опору.5. Холдер для автопутешествийКогда планшет в руках держать не хочется, а дорога предстоит дальняя, соорудите холдер и сажайтесь на заднее место, подвесив планшет на стойки подголовника. Для изготовления холдера понадобится крепкая прозрачная папка, в которой следует проделать отверстия под стойки.6. Заряжай и открывайХотите эффектно открыть крышку бутылки? Зарядное от iPad вам поможет. Разберите его на две части и сорвите крышку одним ловким движением.7. Подставка на все случаи жизниПоставить планшет на устойчивую опору без чехла можно с помощью тонких металлических плечиков. Согните плечики, как на фото, или соорудите любую другую произвольную, но устойчивую конструкцию.8. И снова об опорахНет металлических плечиков? Не беда, картонные коробки всегда найдутся. Вырежьте из коробки три прямоугольника, склейте их и в полученном монолите прорежьте выемку шириной в планшет. Устойчивая опора готова.9. Чехол для планшетаЧехлы для планшетов стоят немало, а долговечностью не отличаются. С нашим лайфхаком вы сможете менять чехлы хоть каждый день! Надуйте шарик и положите на него планшет. Начните медленно спускать воздух, надавливая планшет на шар. Как только воздух сдуется, шарик обтянет планшет чехлом.10. +50% к скорости зарядкиЛюбые мобильные устройства, включая планшет, любят разряжаться в самый неподходящий момент. Одна хитрость поможет зарядить девайс в 2 раза быстрее. Выключите планшет и поставьте его на зарядку. Устройство получит 100% питания и не потратит 50% на обеспечение системных процессов и прочих сервисов.",
        "url": "/blog/design/2018-01-20-10-udobnyh-reshenij-dlya-ispolzovaniya-plansheta.html"
    }
    ,
    
    "blog-it-news-2018-01-20-hyperx-predator-ddr4-rgb-s-sinhronizaciej-podsvetki-html": {
        "title": "HyperX Predator DDR4 RGB с синхронизацией подсветки через ИК",
            "author": "",
            "category": "",
            "content": "HyperX, являющаяся структурным подразделением компании Kingston Technology, представила первые в отрасли модули памяти, в которых применена беспроводная система синхронизации подсветки посредством ИК-излучения.HyperX, являющаяся структурным подразделением компании Kingston Technology, представила первые в отрасли модули памяти, в которых применена беспроводная система синхронизации подсветки посредством ИК-излучения.В модули памяти HyperX серии Predator DDR4 RGB встроены ИК-приемники, позволяющие получать информацию о настройках подсветки.«Вот уже 15 лет наш бренд лидирует в сфере производства и разгона высокопроизводительных модулей памяти. И сейчас мы рады вывести на рынок новые уникальные модули памяти с RGB-подсветкой, — рассказала руководитель направления памяти HyperX Кристи Эрнт (Kristy Ernt). — Синхронизация подсветки HyperX Predator DDR4 RGB при помощи инфракрасного излучения — это совершенно новый метод, который поможет геймерам и оверклокерам придать их ПК неповторимый и уникальный вид».Помимо фирменной системы синхронизации через ИК-приемники в модулях серии Predator DDR4 RGB реализована поддержка и других технологий управления подсветкой, которые будут доступны при установке на совместимые материнские платы. В настоящее время специалисты HyperX контактируют с производителями материнских плат для того, чтобы всесторонне протестировать модули серии Predator DDR4 RGB и обеспечить их совместимость с системами ASUS Aura Sync, Gigabyte RGB Fusion и MSI Mystic Light Sync.Публичная демонстрация новинок состоялась в ходе выставки CES 2018, которая завершилась в минувшую пятницу в Лас-Вегасе (США).Согласно обнародованной информации, отгрузка модулей памяти HyperX Predator DDR4 RGB стартует во II квартале 2018 года. Цены будут объявлены позже.",
        "url": "/blog/it-news/2018-01-20-hyperx-predator-ddr4-rgb-s-sinhronizaciej-podsvetki.html"
    }
    ,
    
    "blog-html-css-2018-01-20-obzor-materinskoj-platy-asus-rog-maximus-x-apex-html": {
        "title": "Обзор материнской платы ASUS ROG MAXIMUS X APEX",
            "author": "",
            "category": "",
            "content": "Для создания этой материнской платы, компания ASUS привлекла профессиональных оверклокеров, учтя их пожелания и внедрив в свое творение новые оригинальные идеи. Результатом этого сотрудничества явилась плата ASUS ROG Maximus X Apex. Она основана на новом чипсете Intel Z370, поддерживающим установку процессоров 8-го поколения Coffee Lake для уже привычного разъема 1151. В ней все сделано для того, чтобы любители разгона смогли выжать из конструктива все возможное и невозможное.Также для этой платы существует большой набор предустановленных профилей (как фирменных, так и сделанных руками энтузиастов) для процессора и памяти.ASUS ROG Maximus X Apex поставляется в красивой большой красно-черной коробке со ставшей уже привычной для всех геймеров эмблеме ROG. Здесь же, на лицевой стороне, кроме названия самой материнской платы и компании-производителя, наличествуют символы, указывающие на то, что эта плата построена на новейшем чипсете Z370 и поддерживает самую передовую технологию Intel Optane. Кроме этого, имеется поддержка NVIDIA SLI и AMD CROSSFIRE. И безусловно не обошлось без привычной для ASUS светодиодной подсветки AURA и возможности самостоятельного украшательства ее с применением деталей, изготовленных на домашних 3D-принтерах.По уже устоявшейся традиции, все особенности и возможности материнской платы указаны на оборотной стороне упаковки. Здесь приведено изображение материнской платы ASUS ROG Maximus X Apex в окружении перечисления всего того, что установлено или что поддерживается этой оверклокерской материнской платой.Внутри основной коробки, под пластиковой крышкой находится сама материнская плата ASUS ROG Maximus X Apex. Подобное решение говорит только о том, что покупателю предлагается далеко не рядовое изделие.Это же подтверждает и комплектация. Здесь есть все, что необходимо и даже больше:\tруководство пользователя;\tдиск с драйверами и фирменным ПО;\tпластиковый фиксатор для удобной установки процессора;\tзаглушка I/O панели;\tчетыре кабеля SATA 6Gb/s, два из которых с Г-образным разъёмом на одном из концов;\tпереходник для удобного подключения корпусных разъёмов ASUS Q-Connector;\tжёсткий мостик для SLI второго поколения;\tспециальная плата расширения DIMM.2 для установки двух накопителей в разъем M.2;\tкомплектный набор из винтов и стоек для крепления устройств формата M.2;\tкронштейны и винты для вентиляторов;\tудлинитель для подключения светодиодной ленты;\tпластиковая накладка с тремя затемнёнными основами для собственного творческого выражения;\tкупон со скидкой для выполнения процедуры оплетения проводов (раундинга);\tкомплект наклеек с различными изображениями серии ROG;\tподставка для чашки с эмблемой ROG.Материнская плата ASUS ROG Maximus X Apex выполнена в формате EATX, то есть имеет размеры 305×272 мм или 12×10,7 дюймов. Иными словами, размер платы несколько больше стандартного ATX (305×244 мм), но вполне умещается в большинство современных корпусов. Плата имеет достаточно массивные радиаторы охлаждения, а все основные элементы выполнены в темных тонах, в том числе и процессорный сокет LGA1151, окрашенный в черный цвет. Помимо этого, данная материнская плата имеет несколько нестандартную форму (не привычная строгая прямоугольная, а с вырезами) — X-Shaped, чтобы сделать ее еще более узнаваемой. Выглядит весьма необычно, правда в корпусе ее рассматривать мало кто будет, скорее такой дизайн подходит в большей степени для открытых стендов.Материнская плата выполнена на черном текстолите с двусторонним монтажом, то есть на оборотной стороне напаяны несколько микросхем, которые по тем или иным причинам не удалось вписать в привычный односторонний монтаж. Все основные радиаторы пассивного охлаждения, выполненные в ломаном дизайне и частично закрывают панель входа/выхода, массивны, но выглядят весьма интересно, придавая плате оригинальный шарм. Впрочем, если есть желание сделать свой собственный, нестандартный дизайн, то на специальной интернет-странице, посвященной 3D печати, можно найти уже готовые образцы (необходимые для производства файлы — прилагаются) или сделать свой собственный корректируя уже готовые решения. Для крепления изготовленных таким образом деталей, компания ASUS предусмотрела специальные точки крепежа (3D mount). Но не забудьте правильно подобрать параметры таких изделий (площадь контакта, материал и т.д.), чтобы не ухудшить теплоотвод.Питание материнской платы и процессора осуществляется по уже обкатанной на предыдущей версии этой модели платы 10-фазной схеме. Для питания процессора размещено два стандартных 8-контактных разъема. Преобразователь основан на цифровом ШИМ-контроллере ASP1405I. Все компоненты узла питания не только процессора, но и платы в целом, отличаются высокой надежностью и стабильностью, поскольку здесь используются только качественные комплектующие от ведущих производителей.Чуть ниже узла питания и процессора располагается все самое интересное. Наличествуют всего два слота для установки оперативной памяти, и поэтому ее общая емкость не может превышать 32 Гб (при условии использования модулей объемом 16 Гбайт). Но это сделано специально, чтобы иметь возможность разгонять тактовую частоту как самого процессора, так и менять тайминги ОЗУ, что серьезно повышает производительность всей системы.Материнская плата ASUS ROG MAXIMUS X APEX получилась весьма интересной и ее можно и нужно рассматривать как хорошо заточенный инструмент для любителей разгона. К ее основным преимуществам следует отнести рациональную компоновку узлов, многообразие внутренних и внешних интерфейсов, заточенных не только на сегодняшний день, но и на ближайшую перспективу, а также надежную элементную базу. Некоторые дизайнерские и инженерные решения могут показаться несколько необычными, однако, ASUS всегда идет своим путем и возможно именно они, станут основным доводом для покупки этой модели. С другой стороны, следует признать, что компания ASUS выпустила продукт, который будет интересен и любителям компьютерных игр. В конечном счете эта системная плата в большей степени ориентирована именно на оверклокеров и любителей разгона, чем на простых геймеров. Впрочем, возможности данной платы вполне могут заинтересовать и рядовых пользователей, но тут уже рациональный подход уходит на второй план, а на первый выходят финансовые возможности будущего покупателя.",
        "url": "/blog/html-css/2018-01-20-obzor-materinskoj-platy-asus-rog-maximus-x-apex.html"
    }
    ,
    
    "blog-html-css-2018-01-20-obzor-materinskoj-platy-asrock-fatal1ty-z370-gaming-itx-ac-html": {
        "title": "Обзор материнской платы ASRock Fatal1ty Z370 Gaming-ITX/ac",
            "author": "",
            "category": "",
            "content": "Как правило, материнские платы форматов mini- и micro- не делают на базе  наборов системной логики, находящихся на вершине каждой серии, поскольку всё равно приходится отказываться от отдельных контроллеров и портов, то есть все ресурсы дорогих чипсетов попросту не будут задействованы. Но порой бывают и исключения, и одну из таких плат мы сегодня протестируем. Это будет модель ASRock Fatal1ty Z370 Gaming-ITX/ac, входящая в серию плат имени известного киберспортсмена Джонатана Уэндела, так же известного под ником Fatal1ty.В компании ASRock создали плату на флагманском для разъёма LGA1151 чипсете Intel Z370 со всеми возможными интерфейсами и беспроводной сетью и сумели уложить всё это в компактный формат mini-ITX.Материнские платы ASRock, выпускаемые под данным брендом имеют игровую направленность и спроектированы с расчётом на повышенную стабильность и надёжность. Например, контакты их портов имеют позолоченное покрытие толщиной 15 мкм, в текстолите используются слои с удвоенной толщиной меди, а в состав систем питания процессоров входят компоненты со значительно увеличенным запасом прочности.Упаковка и комплектацияПлата ASRock Fatal1ty Z370 Gaming-ITX/ac запечатана в компактную коробку, оформленную весьма ярко. Сочетание красного и чёрного цветов всегда привлекает внимание, видимо в ASRock рассчитывали именно на такой эффект, когда оформляли упаковку плат серии Fatal1ty.Компактность упаковки не пошла во вред информативности. На её обратной стороне можно узнать о ключевых особенностях продукта, посмотреть на порты на задней панели и ознакомиться с основными характеристиками.Благодаря стикеру на торце коробки становятся известны не только серийный номер и номер партии, но и масса, размеры, а также страна производства, которой довольно неожиданно оказался Вьетнам, а не безуспешно борющийся с ростом ВВП Китай.Набор комплектующих платы не радует изобилием. Здесь можно найти только два SATA-кабеля, антенну беспроводного модуля связи и заглушку на заднюю панель, а также набор инструкций с DVD с драйверами.Никаких бонусов в комплекте поставки нет, а ведь ASRock Fatal1ty Z370 Gaming-ITX/ac, судя по данным «Яндекс.Маркета», является самой дорогой платой на Intel Z370 в этом формате и стоит 13 000 рублей. Добавим, что на данный продукт предоставляется трёхлетняя гарантия.Дизайн и особенностиASRock Fatal1ty Z370 Gaming-ITX/ac выполнена на восьмислойном текстолите повышенной плотности размерами 170 × 170 мм. Как вы понимаете, при таких размерах платы компоновка элементоов на ней самая плотная, а некоторые из них и вовсе перенесены на обратную сторону текстолита.На заднюю панель платы выведены восемь портов USB 3.1 Gen1 и комбинированный PS/2-порт, два антенных порта для модуля беспроводной связи, видеовыходы DisplayPort и HDMI, порт Intel Thunderbolt 3 (USB 3.1 Gen2 Type-C) и сетевой разъём RJ-45, а также оптический S/P-DIF и пять 3,5-мм аудиоразъёмов.Есть ещё кнопка Clear CMOS, но добраться до неё довольно непросто, особенно если присоединить антенны к модулю беспроводной связи.Без радиатора, закрепляемого винтами, плата выглядит ещё более сложной и перенасыщенной контроллерами и микроэлементами.Процессорный разъём конструктивного исполнения LGA1151 здесь ничем особенным не выделяется, нет даже позолоты контактных игл, как у других разъёмов данной платы ASRock.Соответственно, перечень поддерживаемых платой процессоров здесь также стандартен, и, начиная с самой первой версии BIOS, включает в себя все актуальные модели процессоров Intel восьмого поколения микроархитектуры Core.Слотов DIMM для оперативной памяти стандарта DDR4 на плате всего два, то есть суммарный объём памяти ограничен 32 гигабайтами, чего даже сегодня достаточно для любых игровых задач (и большинства неигровых тоже).Что интересно, по официально поддерживаемой частоте оперативной памяти плата ASRock даст фору многим другим топовым продуктам, поскольку на эту плату можно установить модули с частотой 4333 МГц в двухканальном режиме, а полный перечень протестированных на Fatal1ty Z370 Gaming-ITX/ac модулей можно посмотреть на странице поддержки. Отметим, что контакты в слотах DIMM покрыты 15-мкм золотом.В дополнение к ней на Fatal1ty Z370 Gaming-ITX/ac есть четырёхконтактный разъём подсветки Aura RGB_LED, который может обеспечить питанием светодиодные ленты суммарной мощностью до 36 Вт.Они контактируют со своими «подопечными» через термопрокладки, и, несмотря на малые размеры, их вполне достаточно для охлаждения силовых цепей и чипсета даже при приличном разгоне процессора.",
        "url": "/blog/html-css/2018-01-20-obzor-materinskoj-platy-asrock-fatal1ty-z370-gaming-itx-ac.html"
    }
    ,
    
    "blog-it-news-2018-01-19-novye-naushniki-cougar-phontum-html": {
        "title": "Новые наушники Cougar Phontum с графеновыми диффузорами",
            "author": "",
            "category": "",
            "content": "Компания Cougar показала на выставке CES 2018 игровую гарнитуру Phontum. Новинка построена на базе полноразмерных стереофонических накладных наушников закрытого типа с верхним оголовьем.В комплект поставки данной модели входят две пары сменных амбушюров разного размера. Одна из них предназначена для использования в стационарных, а вторая — в мобильных условиях. Амбушюры заполнены мягким вспененным материалом с эффектом памяти.В каждой из чашек гарнитуры установлен 53-мм широкополосный динамик с диффузором, изготовленным из графена. Чашки имеют двухкамерную конструкцию для улучшения частотных характеристик и качества звучания (напомним, что аналогичное решение применено в анонсированной летом минувшего года гарнитуре HyperX Cloud Alpha).Импеданс наушников — 32 Ома, заявленный производителем диапазон воспроизводимых частот — от 20 Гц до 20 кГц. Микрофон с круговой диаграммой направленности и встроенной системой шумоподавления размещен на съемной гибкой штанге, которая подсоединяется к корпусу левой чашки.Гарнитура оборудована встроенным кабелем длиной 1,2 м с двумя 3,5-мм штекерами mini-jack. В комплект поставки входит удлинитель (1,8 м) для удобства подсоединения к ПК, игровым приставкам и другому стационарному оборудованию.Розничные продажи новинки стартуют в США на следующей неделе. Учитывая особенности данной модели, цену в 55 долл. можно назвать вполне демократичной.",
        "url": "/blog/it-news/2018-01-19-novye-naushniki-cougar-phontum.html"
    }
    ,
    
    "blog-it-news-2018-01-18-igrovye-periferijnye-ustrojstva-i-aksessuary-html": {
        "title": "Игровые периферийные устройства и аксессуары линейки M800 от Cooler Master",
            "author": "",
            "category": "",
            "content": "На проходящей в эти дни выставке CES 2018 компания Cooler Master представила игровые периферийные устройства и аксессуары линейки M800.В их числе — клавиатуры MK850 и MK851, гарнитуру MH850, мышь MM830 и коврик MP860. Все новинки оборудованы подсветкой и имеют запоминающийся дизайн.«Игровая линейка M800 — это всё самое лучшее, что мы можем предложить геймерам. Мы стремились поднять планку максимально высоко, используя уникальные технологии и функции, включая сотрудничество с Aimpad, но не забыли и о конструкции устройств, чтобы игроки чувствовали себя по-настоящему комфортно», — отметил руководитель направления маркетинга комплектующих Cooler Master Брэм Ронген (Bram Rongen).Отличительная особенность клавиатуры MK851 — поддержка технологии Aimpad. Данное решение позволяет использовать некоторые клавиши (в том числе W, A, S и D) в режиме аналогового контроллера для плавного изменения значения соответствующего параметра, варьируя силу нажатия. Данная модель оснащена механическими микропереключателями Cherry MX Red с линейным откликом.Пользователям, которые считают технологию Aimpad излишеством, производитель предлагает конструктивно похожую модель MK850, которая доступна в вариантах с микропереключателями Cherry MX Blue и Brown.Верхняя панель корпуса обеих клавиатур изготовлена из алюминия. Помимо стандартного набора из 104 полноразмерных клавиш предусмотрены дополнительные кнопки для запуска макрокоманд, управления громкостью и медиапроигрывателем, а также два колесика-переключателя. В комплект поставки входит съемная подставка под запястья с мягкой накладкой.Фирменная особенность мыши MM830 — четырехпозиционный указатель, расположенный с левой стороны корпуса. По мнению разработчиков, этот орган управления будет востребован любителями игр жанров MMO и MOBA. В манипуляторе MM830 установлен оптический сенсор Pixart 3360, способный фиксировать перемещения корпуса с точностью до 24 тыс. cpi.Гарнитура MH850 создана на базе полноразмерных наушников закрытого типа с регулируемым верхним оголовьем. В комплект поставки входят сменные амбушюры с тканевой и кожаной отделкой. Микрофон установлен на съемной гибкой штанге.В данной модели реализованы функции эмуляции окружающего звука формата 7.1, а также дополнительного усиления средне- и высокочастотной части звукового сигнала (Focus FX). На корпусе левой чашки размещены колесико регулятора громкости и кнопка отключения микрофона. На правой чашке установлены кнопки активации режимов Focus FX и эмуляции окружающего звука. На внешней стороне корпуса каждой из чашек находится колесико-переключатель, функции которого можно настраивать.И еще одна новинка от Cooler Master — двухсторонний коврик MP860. Он имеет две рабочие поверхности: жесткую для игр и мягкую для работы. Любителей визуальных эффектов порадует настраиваемая подсветка.Согласно предварительной информации, устройства и аксессуары линейки M800 появятся в продаже на территории нашей страны в середине текущего года. Розничные цены новинок будут объявлены позже.",
        "url": "/blog/it-news/2018-01-18-igrovye-periferijnye-ustrojstva-i-aksessuary.html"
    }
    ,
    
    "blog-other-2018-01-09-razrabotchik-zapustil-slack-na-commodore-64-html": {
        "title": "Разработчик запустил Slack на Commodore 64",
            "author": "",
            "category": "",
            "content": "Чем только не занимаются люди в свободное время. Разработчик Джефф Харрис (Jeff Harris) написал клиент для популярного корпоративного мессенджера Slack, чтобы тот работал на Commodore 64.Так как у Commodore 64 нет ни USB-C, ни простого USB порта, исследователю пришлось воспользоваться UserPort. Харрис сделал кабель, который одним концом подключается к UserPort, а на другом конце имеет конвертер USB TTL-RS-232, которым исследователь воспользовался для подсоединения Commodore 64 к Raspberry Pi. При помощи одноплатной «Малинки» Commodore 64 соединяется с интернетом.Когда аппаратный сетап был готов, Харрис написал приложение для Commodore 64, которое позволяет ему общаться с Raspberry Pi и получать от него данные. Затем исследователь создал приложение для самого Raspberry Pi , которое позволяет ему поддерживать связь с API Slack. В результате Raspberry Pi предоставляет Commodore 64 информацию об изменениях на Slack-канале, а также дает возможность отправлять и получать сообщения.\tВсе исходные коды Харрис опубликовал на GitHub, а в своем блоге он выложил подробные инструкции. Отдельную инструкцию по созданию кабеля UserPort -> USB Харрис советует почитать здесь.",
        "url": "/blog/other/2018-01-09-razrabotchik-zapustil-slack-na-commodore-64.html"
    }
    ,
    
    "blog-design-2018-01-09-eko-dizajn-svoimi-rukami-html": {
        "title": "Эко-дизайн своими руками. 8 идей использования в интерьере ящиков",
            "author": "",
            "category": "",
            "content": "щики и паллеты могут стать незаменимой вещью в интерьере. Скептически улыбаетесь? Мы представим вам десять идей-аргументов. Уверены, после прочтения вы немедленно станете разыскивать ящики и паллеты б/у в интернете, ведь с их помощью можно не только обновить интерьер, но и сделать это с минимальными вложениями.1. СтеллажиПервое и самое очевидное применение ящиков – это хранение в них разных вещей. Объединив несколько ящиков, получите большой и функциональный стеллаж. Вопрос с эстетикой легко решить банкой или баллончиком с краской (здесь и далее).2. Прикроватная тумбаПрикроватная тумба в спальне – вещь в хозяйстве полезная. Журнал, кофейная чашка, будильник – на тумбу всегда есть что положить. А если тумбы нет, ну не вписалась покупка в бюджет? Обычный деревянный ящик ее заменит и впишется не только в бюджет, но и в интерьер.3. Гостевой столЕсли без прикроватной тумбы жить сложно, но можно, без стола в гостиной не обойтись. Предлагаем продемонстрировать гостям свой эксклюзивный вкус, сделав столик из паллет. Мастер-класс по изготовлению одного из них сможете увидеть в видео ниже.4. Журнальный столикЕсли размеры гостиной скромны, и паллетам там не место, для журнального столика оно найдется. И не простого, а из ящиков. Четыре ящика, поставленные на ребро, это не только дизайнерский стол, но и вместительная система хранения.5. Мобильный столикВ продолжение темы о столиках – мобильная версия. Очень милый, но, главное, функциональный и передвижной столик с местом хранения можно сделать из одного ящика, прикрепив к нему колесики.6. КроватьДеревянные каркасы, дизайнерские подиумы – зачем тратить деньги, когда с не меньшим успехом можно воспользоваться обычными паллетами? Очень выразительно смотрятся. Если подойти к делу с умом, между паллетами можно организовать ниши для хранения.7. Изголовье кроватиТу же паллету можно использовать для изголовья. И безжалостно красить ее, драпировать, пронзать гвоздями, крепя светильники. Не итальянская мебель – выдержит.8. Мягкий уголокИз паллет можно соорудить каркас для дивана. Матрацы и подушки добавят уголку мягкости и помогут вписать конструкцию в дизайн комнаты.",
        "url": "/blog/design/2018-01-09-eko-dizajn-svoimi-rukami.html"
    }
    ,
    
    "blog-other-2018-01-08-lazernaya-gravirovka-i-3d-pechat-plastinok-iz-dereva-html": {
        "title": "Лазерная гравировка и 3D-печать пластинок из дерева",
            "author": "",
            "category": "",
            "content": "Применение современных высокоточных инструментов для изготовления грампластинок наглядно демонстрирует, что «винил» не умрёт никогда.И пусть это будет уже и не винил вовсе, а другие материалы: пластик или дерево. Но всё равно взгляд на эти поделки умельцев погреет душу каждого аудиофила со стажем.Например, на сайте с инструкциями для самостоятельного изготовления Instructables разработчик Аманда Гассей (Amanda Ghassaei) показывает, как записать аудиофайлы на диски с помощью лазерной резки и послойной 3D-печати на принтере Objet Connex500 особыми фотополимерными материалами, с последующей полимеризацией каждого нанесённого слоя освещением ультрафиолетовой лампой.Такие самодельные диски вращаются с частотой 33 оборота в минуту и воспроизводят 5-6-битный звук с частотой дискретизации 11 кГц. Конечно, это хуже, чем в любом MP3, но граммофон играет вполне узнаваемые мелодии.\tАманда Гассей экспериментирует и с другими материалами: бумагой, пластмассой и деревом. Деревянные пластинки выглядят особенно эффектно.Запись звука на дерево осуществляется с помощью лазерного гравера Epilog 120 Watt Legend EXT и специально написанной программы на языке Processing.",
        "url": "/blog/other/2018-01-08-lazernaya-gravirovka-i-3d-pechat-plastinok-iz-dereva.html"
    }
    ,
    
    "blog-it-news-2018-01-08-deepcool-anonsirovala-serijnyj-variant-korpusa-quadstellar-html": {
        "title": "DeepCool анонсировала серийный вариант корпуса Quadstellar",
            "author": "",
            "category": "",
            "content": "Компания DeepCool представила серийный вариант корпуса Quadstellar, прототипы которого демонстрировались на выставках CES 2017 и Computex Taipei 2017. Отличительная особенность данной модели — сегментирование внутреннего пространства на четыре отсека, каждый из которых вмещает определенные компоненты (блок питания, материнскую плату, карты расширения и накопители).Как утверждают разработчики, такая конструкция позволила обеспечить оптимальные условия для максимально эффективного охлаждения каждого из компонентов системы.Проектирование корпуса Quadstellar проводилось с использованием самых современных инженерных средств. Чтобы добиться максимальной эффективности вентиляции корпуса, процесс рассеивания тепла был тестирован при помощи компьютерной симуляции, на примере физического прототипа и с учетом данных от инфракрасных датчиков.Основой корпуса Quadstellar служит прочный литой каркас, изготовленный из алюминия. Кроме того, в конструкции применены детали из стальных листов SPCC и пластины из тонированного закаленного стекла.В корпусе можно разместить блок питания ATX PS2 глубиной до 300 мм; материнскую плату формфактора mini-ITX, micro-ATX, ATX или E-ATX, а также до восьми карт расширения, в том числе до трех графических адаптеров длиной до 380 мм. Максимальная высота процессорного кулера — 110 мм.В отдельном отсеке находятся корзины для восьми 3,5-дюймовых и пары 2,5-дюймовых накопителей. Кроме того, в корпусе можно разместить еще три 2,5-дюймовых жестких диска или SSD. Мест для 5,25-дюймовых устройств не предусмотрено.Корпус поставляется с пятью 120-мм вентиляторами TF120, четыре из которых установлены под передней панелью, а еще один — на задней стенке. Спереди можно установить в общей сложности до шести 120-мм вентиляторов, сзади — один 120-мм либо два 80-мм, а сбоку — пару 120-мм.В случае оснащения ПК жидкостной системой охлаждения предусмотрена возможность размещения радиатора шириной до 360 мм под передней панелью и шириной до 240 мм на нижней плоскости.Корпус оборудован настраиваемой подсветкой. Выбрать желаемый цвет и режим работы подсветки, а также частоту вращения установленных внутри вентиляторов можно через фирменное мобильное приложение Quadstellar.На коммутационную колодку выведены два порта USB 3.0, а также разъемы для подключения наушников и микрофона.Размеры корпуса Quadstellar — 538×483×493 мм; вес — 14,5 кг.",
        "url": "/blog/it-news/2018-01-08-deepcool-anonsirovala-serijnyj-variant-korpusa-quadstellar.html"
    }
    ,
    
    "blog-other-2018-01-07-stilnyj-mediapleer-slice-iz-modulya-raspberry-pi-html": {
        "title": "Стильный медиаплеер Slice из модуля Raspberry Pi",
            "author": "",
            "category": "",
            "content": "В апреле 2014 года Raspberry Pi Foundation выпустила новый продукт: вычислительный модуль, который оснащён процессором BCM2835 как у Raspberry Pi, программируемой флэш-памятью и 512 МБ ОЗУ, но при этом вставляется в обычный разъём памяти DDR2 SODIMM.Такие модули предназначены для энтузиастов, которые хотят конструировать материнские платы собственного дизайна для специальных приложений. На всякий случай, Raspberry Pi Foundation выпустила и базовую материнскую плату для таких модулей Compute Module IO Board.В середине года вышел комплект разработчика Compute Module Development Kit, так что мастери — не хочу.С тех пор появилось много интересных проектов с использованием камера-модуля, в том числе много потребительской электроники, на что и рассчитывали создатели. Одним из первых таких проектов стала программируемая камера OTTO, которая умеет снимать фото, видео и анимированные gif’ы. Её можно укомплектовать сенсорами и запрограммировать практически на что угодно.Сейчас вышел ещё один красивый проект — медиаплеер Slice в стильном металлическом корпусе с полоской из 25 разноцветных программируемых светодиодов, которые магически переливаются всеми цветами радуги для «информации о событиях и вау-фактора», как сказано на странице краудфандинговой кампании на Кикстартере (кампания идёт успешно).Плеер работает на XMBC, он подключается к локальной сети по Ethernet, записывает фильмы на встроенный HDD, показывает 3D-видео и HD-кино в любом формате.",
        "url": "/blog/other/2018-01-07-stilnyj-mediapleer-slice-iz-modulya-raspberry-pi.html"
    }
    ,
    
    "blog-design-2018-01-07-kak-den-nachnesh-tak-ego-i-provedesh-html": {
        "title": "Как день начнешь, так его и проведешь. 10 лайфхаков для бодрого утра",
            "author": "",
            "category": "",
            "content": "Как сделать, чтобы утренний подъем был наполнен радостью и обещал приятный день? Как начать утро, чтобы день был энергичным и продуктивным? Известно, первый час дня определяет его успех. Хватит рычать по утрам.1. Планируйте завтрашний деньЕсли с вечера не распланировать завтрашний день, утром может показаться, что торопиться некуда, и можно еще поваляться. План поднимет с кровати быстрее будильника и позволит приступать к делам практически сразу, не тратя драгоценное время на лишнюю суету2. Сделайте заготовки к завтракуКогда утром на кухне ждет гора немытой посуды, а не завтрак, вставать действительно лень. Помойте посуду с вечера, отфильтруйте воду, заправьте кофемашину, смешайте сухие хлопья с орехами и сухофруктами. Ммм, как вкусно. Скорей бы утро!3. Держите дистанциюПоставьте будильник как можно дальше от кровати. Вам придется как минимум встать. Или даже не один раз. Движение генерирует энергию, а энергия требует движения. Сон как рукой снимет!4. Умойтесь холодной водойТрудно лишь в первый раз. С каждым днем будет легче, и в какой-то момент вы поймете, что жить без него не можете. Без утреннего умывания ледяной водой. Какие бонусы? Мгновенный тонизирующий эффект. В конце концов, это полезно для кожи.5. Травяной лед для лицаАльтернатива ледяному умыванию – протирание лица травяным льдом. Процедура не только тонизирует и пробуждает, но и ухаживает за кожей, очищая ее, разглаживая, подтягивая. Приготовьте травяной настой – из ромашки, мяты, петрушки или чая. Залейте в форму для льда и заморозьте.6. Выпейте стакан водыПосле 6-8 часов сна организм обезвожен. А обезвоженный организм чувствует себя уставшим. Умылись? Выпейте стакан чистой воды. Этого бывает достаточно, чтобы даже после короткого сна быстро прийти в себя. В воду можно добавить немного лимонного сока и меда.7. Заправьте постельЗаправленная постель лишает вас последнего шанса нырнуть в нее обратно. Заправьте и забудьте. День начался. Сновидения – в прошлом.8. Экспресс-головомойкаЕсли времени на мытье, сушку и укладку волос нет, воспользуйтесь экспресс-способом приведения шевелюры в порядок. Промойте шампунем зону челки и висков, быстро просушите феном и зачешите в хвост. Эффект свежевымытых волос!9. Экспресс-завтракОмлет в кружке – это не только быстро и вкусно, но и модно. Тренд торжественно шествует по миру! Взбейте в кружке яйца с молоком, сыром, помидорами, ветчиной (ингредиенты по вкусу). Посолите и поперчите. Поставьте на 1 минуту в СВЧ печь на всю мощность. Перемешайте и прогрейте еще 1,5 минуты. Приятного аппетита.10. Магия числа «21»Знаете ли вы, что привычка становится второй натурой за 21 день? Пользуйтесь этим. Хотите приучить себя вставать в 6.30? Заставьте себя вставать в 6.30 в течение трех недель, не пропуская ни дня. Это войдет в привычку!",
        "url": "/blog/design/2018-01-07-kak-den-nachnesh-tak-ego-i-provedesh.html"
    }
    ,
    
    "blog-it-news-2018-01-07-igrovye-aksessuary-ot-hyperx-na-ces-2018-html": {
        "title": "Игровые аксессуары от HyperX на CES 2018",
            "author": "",
            "category": "",
            "content": "HyperX, являющаяся структурным подразделением компании Kingston Technology, представила на выставке CES 2018 сразу несколько игровых устройств: беспроводную гарнитуру Cloud Flight, клавиатуру Alloy Elite RGB и мышь Pulsefire Surge.Беспроводная гарнитура HyperX Cloud Flight обеспечивает пользователю максимальную свободу движений и способна проработать до 30 ч без подзарядки (при отключенной подсветке). При этом новинка унаследовала фирменный комфорт и отличное качество звука предыдущих моделей HyperX.Гарнитура HyperX Cloud Flight создана на базе полноразмерных накладных наушников закрытого типа с верхним оголовьем. В каждой из чашек установлен 50-мм широкополосный динамик с неодимовым магнитом. Конструкция крепления чашек позволяет поворачивать их на 90°. Электретный микрофон со встроенной системой шумоподавления размещен на съемной гибкой штанге, которая подсоединяется к корпусу левой чашки.Гарнитуру HyperX Cloud Flight можно подключить как по беспроводному каналу, так и при помощи кабеля с 3,5-мм штекером mini-jack, благодаря чему обеспечивается совместимость с самыми разными устройствами. Беспроводное соединение осуществляется по радиоканалу в частотном диапазоне 2,4 ГГц; заявленный радиус действия — до 20 м.Логотипы на внешних сторонах чашек оборудованы подсветкой, которая может работать в двух режимах: постоянном и «дышащем».Непосредственно на гарнитуре размещены органы управления подсветкой, режимом работы микрофона и громкостью, а также выключатель питания. Зарядка встроенной аккумуляторной батареи осуществляется от порта USB.Модель HyperX Cloud Flight сертифицирована TeamSpeak и Discord. Вес гарнитуры с микрофоном составляет 315 г.Клавиатура Alloy Elite RGB стала первой механической моделью в линейке HyperX, оснащенной полноцветной подсветкой. В этой клавиатуре применены механические микропереключатели Cherry MX (покупатели смогут выбрать наиболее подходящий из трех вариантов — Blue, Brown или Red). Основой корпуса служит прочная стальная рама.Помимо стандартного набора из 104 полноразмерных клавиш у Alloy Elite RGB имеются дополнительные кнопки для управления программным медиапроигрывателем и широкое колесико регулировки громкости. В комплект поставки входят несколько сменных колпачков с отделкой под титан, а также съемная подставка под запястья.Все клавиши оборудованы подсветкой. Пользователь может выбрать желаемый цвет из более чем 16 млн вариантов и одну из четырех градаций яркости для каждой клавиши. Настройка подсветки осуществляется при помощи фирменного приложения NGenuity. Во встроенной памяти клавиатуры можно сохранить до трех профилей с индивидуальными настройками подсветки.В модели Alloy Elite RBG реализованы функции N-Key Rollover и anti-ghosting. Кроме того, предусмотрен игровой режим.Клавиатура рассчитана на подключение к порту USB и оборудована встроенным кабелем длиной 1,8 м. Предусмотрен дополнительный порт USB для подсоединения мыши или другого устройства.Размеры корпуса клавиатуры с учетом подставки под запястья — 444×226,8×37,4 мм; вес (включая кабель) — 1467 г.Проводная мышь HyperX Pulsefire Surge выполнена в корпусе эргономичной формы и оборудована оптическим сенсором Pixart 3389, который способен регистрировать перемещения манипулятора с точностью до 16 тыс. cpi. В паре основных клавиш установлены микропереключатели Omron с заявленным ресурсом не менее 50 млн нажатий.При помощи фирменного приложения HyperX NGenuity пользователи могут изменять функции органов управления мыши и записывать макрокоманды.Модель HyperX Pulsefire Surge оснащена подсветкой логотипа на верхней панели и окантовки, которая опоясывает корпус по периметру. Предусмотрена возможность выбора желаемого цвета из более чем 16 млн вариантов, а также различных эффектов, в том числе динамических.«Наш выбор продукции для выставки CES в очередной раз подчеркивает желание HyperX дать геймерам любого уровня максимально эффективные и надежные аксессуары. И неважно, любите ли вы шутеры от первого лица для консолей, дуэли на ПК или серьезные киберспортивные соревнования с игроками со всего мира, — отметил вице-президент HyperX Марк Лэтем (Mark Leathem). — Наши новые продукты дают игрокам свободу, комфорт и возможность полной настройки, чтобы им оставалось только одно — наслаждаться игрой».Продажи клавиатуры HyperX Alloy Elite RGB в российских розничных и интернет-магазинах стартуют в конце января. Цена данной модели составит порядка 12 тыс. руб. Начало поставок мыши HyperX Pulsefire Surge и гарнитуры HyperX Cloud Flight запланировано на II квартал. Цены этих устройств будут объявлены позже.",
        "url": "/blog/it-news/2018-01-07-igrovye-aksessuary-ot-hyperx-na-ces-2018.html"
    }
    ,
    
    "blog-other-2018-01-06-kak-sdelat-internet-spidometr-html": {
        "title": "Как сделать Интернет-спидометр на светодиодах и плате BeagleBone",
            "author": "",
            "category": "",
            "content": "Для измерения скорости интернета существует множество различных утилит. Но ни одна из них не выглядит так красиво, как самодельный интернет-спидометр на плате BeagleBone с лентой светодиодов, который смастерил американский инженер Тайлер Уорман (Tyler Worman).Для изготовления спидометра использовалась плата BeagleBone Black и два модуля Programable Realtime Unit (PRU). Устройство замеряет скорость передачи данных и отображает результат на трёхцветной светодиодной ленте.\tЕсли вам не нравится такой вариант визуализации, то можно изготовить альтернативный спидометр в стиле стимпанк с помощью Raspberry Pi и датчика давления. Или можно заказать такой прибор на Кикстартере.Прибор снимает информацию с интернет-маршрутизатора, а затем конвертирует её в аналоговую шкалу для экрана со стрелкой. Данные обновляются каждые 10 секунд.",
        "url": "/blog/other/2018-01-06-kak-sdelat-internet-spidometr.html"
    }
    ,
    
    "blog-other-2018-01-05-didzhejskij-pult-iz-kassetnogo-pleera-html": {
        "title": "Как сделать диджейский пульт из кассетного плеера своими руками",
            "author": "",
            "category": "",
            "content": "Многие видели, как работают диджеи, ловко прокручивая пластинки, замедляя или ускоряя их ход, а также прокручивая против хода движения — такие манипуляции создают уникальные звуки, которые не записаны на пластинку изначально. Подобное искусство требует определённой сноровки.Оказывается, похожего эффект можно достигнуть, используя детали старого кассетного аудиоплеера, что и продемонстрировал инженер и аудиофил Джереми Белл (Jeremy Bell). Он разработал установку Scrubboard, которая генерирует эффекты не хуже профессионального диджейского пульта.\tКонцепция очень проста: нужно извлечь считывающую головку из плеера, сохранив контакт с основной платой. Плёнка из кассеты натягивается на доску, а если проводить по ней головкой, то мы получаем такие же уникальные эффекты.",
        "url": "/blog/other/2018-01-05-didzhejskij-pult-iz-kassetnogo-pleera.html"
    }
    ,
    
    "blog-design-2018-01-05-9-neobychnyh-sposobov-ispolzovaniya-kancelyarskogo-skotcha-html": {
        "title": "9 необычных способов использования канцелярского скотча",
            "author": "",
            "category": "",
            "content": "Скотч - очень нужная канцелярская штука. Умельцы ради развлечения придумали делать из него сумки и кошельки. Кто-то использует его для того, чтобы правильно наносить макияж. Но это всё очень скучно и неоригинально.1. Почисти клавиатуруКогда нет никакой возможности вычистить мерзкие крошки, завалившиеся между кнопками клавиатуры, на помощь придет липкая лента. Проведи липкой стороной ленты по щелям между кнопками клавиатуры. Весь мусор прилипнет к скотчу.2. Почисти одеждуКогда липкие ролики для одежды закончились, на помощь придет надежная широкая липкая лента.3. Заклей мозолиНовую обувь бывает сложно разносить. Чтобы не натереть себе жуткую водяную мозоль, заклей скотчем ножки там, где новая обувь поджимает или натирает. Вечер спасен!4. Собери осколки стеклаПровели липкой стороной широкого скотча по месту, где разбилось что-то стеклянное. Мелкие острые осколки останутся на скотче.5. Собери ртутьРтутные пары из разбитого термометра невероятно вредны для здоровья. Чтобы не иметь дела с десятками разбежавшихся ртутных шариков, собери их липкой лентой. Быстро и безопасно!6. Почини шнуркиЕсли заводские наконечники шнурков потеряли свой первоначальный вид, оберни кончики шнурков липкой лентой. Шнурки снова как новые.7. Защити пластиковую картуМагнитные ленты на картах часто повреждаются, из-за этого карты выходят из строя. Чтобы этого не произошло, наклей поверх магнитной ленты кусочек скотча. И лента будет цела, и карты будет прекрасно работать — скотч передаче сигнала не мешает.8. Удали следы клеяЕсли этикетка от чашки отодралась, а клейкая основа нет, воспользуйся скотчем. Приклей его к загрязненной области и резко оторви. Клея как не бывало.9. Упорядочи проводаСверни провода в один пучок и зафиксируй их скотчем. Долгожданный порядок в проводах наведен!",
        "url": "/blog/design/2018-01-05-9-neobychnyh-sposobov-ispolzovaniya-kancelyarskogo-skotcha.html"
    }
    ,
    
    "blog-other-2018-01-04-napravlennaya-wifi-antenna-html": {
        "title": "Направленная WiFi-антенна из ложки и детской бутылочки",
            "author": "",
            "category": "",
            "content": "Хорошо, когда живёшь в многоквартирном доме, а соседи не отличают WEP от WPA — всегда есть резервный канал доступа в интернет. Но что делать, если хотспот находится в сотнях метров, а бесплатный интернет ну очень нужен?В таких случаях единственный вариант подключения — использовать направленную WiFi-антенну для усиления сигнала. С её помощью можно подключиться к далёким хотспотам и заметно улучшить качество сигнала. В интернете есть разные инструкции по сборке направленных WiFi-антенн, но вряд ли кто-то додумался до такого примитивного решения, как у программиста Кристофера Коннелла (Christopher Connell), которого судьба несколько лет назад занесла в Таиланд, где интернет в то время был довольно дорогой и по паспорту.Коннелл в своём блоге рассказывает, что успешно соорудил усилитель сигнала WiFi из самых примитивных деталей общей стоимостью не более 50 долларов, это с учётом USB-модема (собственно, на него пришлось больше половины стоимости).Кроме него, понадобилось следующее.\tДетская бутылочка\tUSB-кабель (с усилителем, если длина превышает 3 метра)\tКусачки\tИзолента\tСиликоновый клей\tПластиковая сетка\tПроволочная ложка параболической формыЭкзотическая деталь здесь — проволочная ложка, которая используется как рефлектор антенны. В центре сетки проделывается отверстие, куда вставляется кабель для USB-модема, защищённого от влаги бутылочкой (в Таиланде ливни — обычное дело, а ведь антенну мы выставим на улицу). Всё это закрепляется клеем и изолентой при необходимости.Самое сложное — установить USB-приёмник точно в точке фокусировки сигнала. Расстояние от дна рефлектора до приёмника вычисляется по формуле f=D^2/(16c), то есть квадрат диаметра, делённый на глубину антенны, умноженную на 16.Кристофер Коннелл успешно подключился к WiFi-точке в магазине на другом конце улицы, как и планировал. Он с удивлением обнаружил, что принимает сигнал даже от хотспотов в домах на расстоянии более 1 километра от его жилища. Очень неплохо для антенны из ложки и детской бутылочки!",
        "url": "/blog/other/2018-01-04-napravlennaya-wifi-antenna.html"
    }
    ,
    
    "blog-design-2018-01-04-10-geometricheskih-polok-html": {
        "title": "10 геометрических полок для придания оригинальности интерьеру",
            "author": "",
            "category": "",
            "content": "Иногда для преображения дома хватает даже одной, незначительной детали. Например, оригинальной полки для книг, сувениров и красивых мелочей. А создать такую полку своими руками приятно вдвойне.1. Квадратная полкаРаз, два, и готово! На стене такая геометрическая полка выглядит как крутой постер.2. Подвесная полкаЯркий шнурок превратит простую деревянную полочку в стильный предмет интерьера. Повесить такую можно в любом уголке вашего дома, а сделать ее проще простого.3. Угловая полкаЕсли в вашем доме много «выпирающих» углов, они ни в коем случае не должны пустовать. Такая полочка поможет здорово сэкономить пространство. Читайте, как сделать такую своими руками.4. Разноцветные ящичкиДобавьте своих любимых красок — и вы просто глаз не сможете оторвать от этих милых ящичков, прибитых к стене вашей комнаты. Правило «чем меньше, тем лучше» в этом случае работает безотказно. Пора делать!5. Полка «Весы»Во-первых, эта полочка просто потрясающе выглядит, а во-вторых, с ее помощью вы сможете по-новому организовать свое рабочее пространство. На перевешивающей «чаше» можно хранить лишь те книги, которые вы хотите прочесть в первую очередь. Как вам такая идея?6. Полка «Лабиринт»Полка для тех, кто знает, что нет ничего лучше творческого беспорядка. Просто вооружитесь большим количеством дощечек и начинайте творить! Инструкция тут.7. Полка, сгибающаяся под тяжестью книгОригинально, правда? И не говорите, что вы не сможете сделать такую сами!8. Модульная полкаПростая деревянная полка, но как эффектно она выглядит! Секрет в этих бесконечных геометрических нишах, куда так и хочется что-то поставить! Сделайте такую прямо сейчас.9. Полка «Ветка»Если на вашей стене уже висит куча одиноких маленьких полочек, просто соедините их одной простой деталью, и получится... настоящее произведение искусства! Такая «ветка» будет круто смотреться и в спальне, и на кухне, и в ванной. Делаем?10. Треугольная полкаЕсли под простой треугольной полкой разместить точно такую же, но перевернутую, получится создать впечатляющий эффект зеркального отражения. Расставьте на получившиеся полки похожие предметы, и гости не смогут отвести взгляд от вашей новой стены! Инструкция.",
        "url": "/blog/design/2018-01-04-10-geometricheskih-polok.html"
    }
    ,
    
    "blog-it-news-2018-01-04-igrovuyu-mysh-steelseries-rival-600-html": {
        "title": "Игровую мышь SteelSeries Rival 600 оборудовали двумя оптическими сенсорами",
            "author": "",
            "category": "",
            "content": "На проходящей в эти дни в Лас-Вегасе (США) выставке CES 2018 компания SteelSeries анонсировала проводную мышь Rival 600, которая адресована требовательным любителям динамичных компьютерных игр.Отличительная особенность новинки — система регистрации перемещений TrueMove3+, которую глава SteelSeries Эхтишам Раббани (Ehtisham Rabbani) назвал настоящим технологическим прорывом в сфере игровых манипуляторов.В мыши Rival 600 установлены два оптических сенсора. Основной (TrueMove3) обеспечивает регистрацию перемещений корпуса манипулятора с точностью до 12000 cpi при скорости движения до 350 дюймов в секунду (8,89 м/с) и ускорении до 50g. Дополнительный сенсор служит исключительно для определения расстояния до опорной поверхности.Как утверждают разработчики, такая конструкция позволила достичь высокой точности и устранить нежелательные смещения курсора в момент отрыва и возврата мыши на рабочую поверхность. У пользователя есть возможность изменять значение разрешающей способности в диапазоне от 100 до 12000 cpi с шагом в 100 cpi, а также настраивать дистанцию отрыва в пределах от 0,5 до 2 мм.Модель Rival 600 выполнена в корпусе эргономичной формы, которая рассчитана на управление правой рукой и подходит для любого типа хвата. Панели корпуса изготовлены из армированного пластика и снабжены мягким на ощупь покрытием черного цвета. С правой стороны имеются две силиконовые накладки.Набор органов управления включает пару основных клавиш, колесико прокрутки и четыре дополнительные кнопки. Три из них расположены с левой стороны корпуса, а еще одна — в центре верхней панели. В паре основных клавиш установлены фирменные микропереключатели с заявленным ресурсом не менее 60 млн нажатий.Вес мыши без учета кабеля составляет 96 г. Пользователь может изменять вес и смещать центр тяжести манипулятора при помощи восьми грузиков весом по 4 г каждый, которые входят в комплект поставки. Для размещения балласта предусмотрены специальные ниши под съемными боковыми панелями (по четыре с каждой стороны).В мыши установлен 32-разрядный ARM-процессор. Управление всеми параметрами осуществляется через фирменное ПО SteelSeries Engine. В частности, предусмотрена возможность изменять функции органов управления, записывать макрокоманды и сохранять пользовательские настройки во встроенной памяти манипулятора. Для любителей визуальных эффектов имеется 8-зонная настраиваемая подсветка.Модель Rival 600 рассчитана на подключение к порту USB и укомплектована отсоединяемым кабелем длиной 2 м, который заключен в мягкую на ощупь резиновую оболочку.Размеры корпуса манипулятора — 131×69×43 мм. Новинка уже доступна для заказа на веб-сайте производителя по цене примерно 80 долл.",
        "url": "/blog/it-news/2018-01-04-igrovuyu-mysh-steelseries-rival-600.html"
    }
    ,
    
    "blog-design-2018-01-03-10-lajfhakov-s-batarejkami-html": {
        "title": "10 лайфхаков с батарейками - на что способны батарейки?",
            "author": "",
            "category": "",
            "content": "Как добиться того, чтобы батарейка прослужила по-максимуму? Как добыть огонь без спичек и зажигалки? Как «похоронить» батарейку правильно? Цивилизованному человеку представить жизнь без батареек трудно. Но, как показывает опыт, мы недостаточно информированы о возможностях вещей, которые окружают наш быт. 10 лайфхаков с батарейками – тому подтверждение.1. Мобильный обогреватель для рукЛюди делятся на два типа. Одни даже в мороз чувствуют себя комфортно. Другие мерзнут в середине июля. Если проблема холодных рук вам знакома не понаслышке, держите под рукой, а вернее – в руках, мини-обогреватель из батареек. Оберните батарейку фольгой, закрепив ее на полюсах-контактах. Зажмите полюса – и наслаждайтесь теплом. Перед тем как взять мини-обогреватели с собой, убедитесь, что батарейки заряжены.2. Заряженная или севшая – как узнать?Но как узнать, заряжена ли батарейка без приборов? Уроните батарейку на стол минусовой стороной с небольшой высоты (2-3 см). Разряженная звонко отскочит и упадет. Заряженная, вероятнее всего, приземлится на полюс с глухим звуком.3. Электромагнит своими рукамиС помощью простых предметов – батарейки, изолированной медной проволоки (не менее 1,5 метров) и большого гвоздя/болта, можно сделать мощный электромагнит. Намотайте проволоку на гвоздь от одного конца к другому. У каждого конца гвоздя должны остаться «хвостики» для подключения к батарейке. Как только вы присоедините концы проволоки к батарейке, конструкция превратится в электромагнит. Ищите или подбирайте им любые металлические предметы. После рассоединения элементов электромагнит теряет силу.4. Огонь из батарейкиОдин из любимых трюков лайфхакеров (и не только) – добыча огня с помощью батарейки. Понадобится полоска фольги с бумажным основанием (например, от жевательной резинки) шириной 6-7 мм у концов с заужением до 2 мм по центру. Приложите концы полоски к полюсам батарейки и поднесите устройство к бумаге, которая тотчас воспламенится.5. AAA вместо AAНужна AA, а под рукой лишь AAA? Проблема решается просто – кусочком фольги, который удержит батарейку в разъеме и приведет устройство в рабочее состояние.6. Вскрытие батарейки «Крона»Алкалиновые батарейки «Крона» содержат 6 батареек типа АААА с напряжением в 1,5 В, которые легко превращаются в батарейки AAA с помощью вышеуказанного лайфхака.7. Зачем мять разряженные батарейки?Копейка рубль бережет. Не выбрасывайте севшие батарейки. Если разряженную батарейку помять, например, зубами или плоскогубцами, она обретет импульс для второй жизни. Кстати, сильно мятая батарейка может протечь и испортить девайс.8. Стилус для смартфонаМежду прочим, минусовая сторона пальчиковой батарейки может быть стилусом для емкостного сенсорного экрана.9. Подарок будущим поколениямБатарейка, выброшенная в мусорное ведро, нанесет природе серьезный урон. Оказавшись на улице, она загрязнит вредными компонентами 20 квадратных метров земли или 400 литров воды. Складывайте отработанные батарейки в пластиковую бутылку, а пока она заполняется – найдите ближайший пункт сбора батареек, которых в России, увы, немного.10. Ответственность перед природой с IkeaСеть магазинов Ikea возобновила прием отработанных батареек и ртутьсодержащих ламп. Никакой платы за сбор и последующую утилизацию батареек магазин не берет. Ищите спецконтейнеры у выхода из магазина!",
        "url": "/blog/design/2018-01-03-10-lajfhakov-s-batarejkami.html"
    }
    ,
    
    "blog-design-2018-01-02-10-poleznyh-sovetov-po-ispolzovaniyu-mobilnogo-telefona-html": {
        "title": "10 полезных советов по использованию мобильного телефона",
            "author": "",
            "category": "",
            "content": "Современный человек уже не представляет, как можно в жизни обходиться без телефона. Но иногда мобильный становится причиной нервного расстройства. Например, когда опаздываешь на важную встречу, а заряд аккумулятора почти исчерпан. Как оперативно зарядить смартфон и другие полезные лайфхаки для телефона – в следующем познавательном ТОП 10.1. Как просушить телефон?Если телефон намок, возьмите герметично закрывающийся пакет и насыпьте в него рис. Положите в рисовое SPA смартфон, достав из него сим-карту и аккумулятор. Плотно закройте пакет и оставьте на 24 часа, чтобы рис впитал влагу. В 60% случаев телефон заводится и дает возможность сделать нужные звонки и перенести с него важную информацию.2. Усилитель звука из мискиЧтобы увеличить громкость звучания телефона, можно прокачать его программой Volume Booster Plus. Но приложение работает не на всех гаджетах и делает звук громче лишь на 20%. Оптимизировать громкость динамиков можно иначе. Положите телефон во время прослушивания музыки в пустую миску или стакан. Звук станет громче, объемнее и приятнее на слух.3. Чехол из воздушного шарикаИз воздушного шарика можно сделать красивый чехол для мобильника. Надуйте шар, зажмите горлышко рукой. Положите на него смартфон и, надавливая на поверхность, медленно шарик сдуйте. Когда воздух спустится полностью, телефон будет облачен в резиновый кейс по контуру. Расправьте края и отрежьте «шейку».4. Подставка из очковХотите комфортно смотреть видео? Солнечные очки превратятся в удобную подставку для телефона, если расположить их так, как указано на картине.5. Подставка из крабика для волосС не меньшим успехом можно воспользоваться крабиком для волос. Разожмите заколку и вставьте в «пасть» смартфон. Все гениальное – просто!6. Фейковый звонок или смсВходящий звонок может выручить в неловкой или затруднительной ситуации. Обыкновенно для этого пользуются помощью друга. С приложением Fake Call & SMS звонок можно сделать самому, что, согласитесь, проще и надежнее.7. Витой провод для смартфонаДекоративный и удобный витой провод для зарядки мобильного можно сделать из прямого. Намотайте шнур на карандаш, закрепите концы скотчем или зажимами. Нагревайте провод феном в течение 2-3 минут, охладите. Снимите спираль с карандаша.8. Линза для макросъемокМакросъемка телефоном? Это невозможно, скажете вы. Но если капнуть на камеру телефона маленькую каплю воды, у гаджета появляется «макроглаз», с помощью которого можно снимать мелкие надписи на монетах, тычинки и пестики цветов.9. Стилус из карандаша и фольгиРисовать на экране пальцем неудобно. Для этого предназначен стилус, сделать который легко своими руками. Достаточно намотать на карандаш фольгу, аккуратно прижав края. Стилус к работе готов.10. Как зарядить телефон быстроМногие из вас сталкивались с ситуацией, когда нужно срочно выходить из дома, а зарядка телефона почти на нуле. Время заряда можно значительно сократить, если перевести телефон в режим «Авиа». Отключится огромное количество процессов и модулей, который потребляют энергию. Увы, принимать звонки и звонить самому в этом режиме не получится.",
        "url": "/blog/design/2018-01-02-10-poleznyh-sovetov-po-ispolzovaniyu-mobilnogo-telefona.html"
    }
    ,
    
    "blog-it-news-2018-01-02-portativnaya-kolonka-as-sven-ps-465-uzhe-v-prodazhe-html": {
        "title": "Портативная колонка АС SVEN PS-465 уже в продаже",
            "author": "",
            "category": "",
            "content": "Компания SVEN объявила о старте розничных продаж портативной акустической системы PS-465. Новинка выполнена в черном корпусе-моноблоке, изготовленном из АБС-пластика черного цвета.В брутальном дизайне этой модели отчетливо прослеживаются мотивы бумбоксов конца 80-х. Для удобства переноски сверху предусмотрена широкая ручка.Воспроизведение звука обеспечивают два широкополосных динамика с 95-мм диффузорами. Для более убедительного звучания низкочастотных составляющих в торцах корпуса установлены пассивные радиаторы.Заявленный в спецификации диапазон воспроизводимых частот — от 100 Гц до 20 кГц; максимальная звуковая мощность (RMS) — 2×9 Вт.Подключение внешних источников звукового сигнала возможно как по кабелю (через аналоговый линейный вход), так и по интерфейсу Bluetooth. Максимальный радиус беспроводного соединения — 10 м; реализована поддержка профилей HSP, HFP, A2DP и AVRCP.Система PS-465 оборудована встроенным УКВ-радиоприемником, обеспечивающим прием программ FM-радиостанций в частотном диапазоне от 87,5 до 108 МГц, а также цифровым медиапроигрывателем, который способен воспроизводить звуковые файлы различных форматов с карт памяти формата microSD и внешних USB-накопителей.Для удобства управления и настройки на передней панели корпуса установлен небольшой монохромный ЖК-дисплей.Источником автономного питания системы служит встроенная литий-ионная aккумуляторная батарея емкостью 1800 мA•ч. Зарядить ее можно от ПК или адаптера с выходом USB.Размеры корпуса SVEN PS-465 — 400×190×154 мм; вес — 2,05 кг.",
        "url": "/blog/it-news/2018-01-02-portativnaya-kolonka-as-sven-ps-465-uzhe-v-prodazhe.html"
    }
    ,
    
    "blog-other-2018-01-01-raspberry-pi-3-poluchit-oficialnuyu-podderzhku-android-html": {
        "title": "Raspberry Pi 3 получит официальную поддержку Android",
            "author": "",
            "category": "",
            "content": "Миникомпьютер Raspberry Pi 3, представленный в феврале 2016 года, не испытывает недостатка в поддерживаемых ОС: в частности, пользователям доступны несколько дистрибутивов Linux и Windows 10 IoT Core.В репозитории Android Open Source Project (AOSP) было замечено появление новой ветки, специально созданной для Raspberry Pi 3. В основном эта секция репозитория посвящена устройствам Nexus, так что увидеть в AOSP сторонний девайс – довольно необычно. Пока ветка Pi 3 пуста, однако вскоре должна начать наполняться кодом.Что именно задумали разработчики Google пока неясно, но с появлением официальных исходников, установка Android на Raspberry Pi 3 станет значительно проще. К тому же, после этого пользователи Pi 3 получат доступ к миллионам приложений, которые позволят найти множество новых применений для other-девайса.Напомним, что Raspberry Pi 3 обладает четырехядерным 64-битный процессором 1,2 Ггц ARM Cortex-A53, благодаря которому компьютер работает в два раза быстрее, чем Pi 2. Остальные характеристики не изменились по сравнению с предыдущей моделью: все тот же 1 Гб RAM, 4 USB-порта, 40-pin GPIO, HDMI, micro SD, 3,5-мм аудиоразъем и так далее. Главная особенность Pi 3: поддержка Wi-Fi 802.11n, Bluetooth 4.1 и BLE, которых ранее так не хватало пользователям. Одноплатный компьютер по-прежнему стоит всего $35.",
        "url": "/blog/other/2018-01-01-raspberry-pi-3-poluchit-oficialnuyu-podderzhku-android.html"
    }
    ,
    
    "blog-design-2018-01-01-kak-vybrat-razmer-diagonali-tv-html": {
        "title": "Как выбрать размер диагонали ТВ",
            "author": "",
            "category": "",
            "content": "Простое изображение, иллюстрирующее критерии выбора диагонали телевизора, в зависимости от удаленности зрителя от аппарата.",
        "url": "/blog/design/2018-01-01-kak-vybrat-razmer-diagonali-tv.html"
    }
    ,
    
    "blog-design-2018-01-01-10-sposobov-primeneniya-magnitov-v-bytu-html": {
        "title": "10 способов применения магнитов в быту",
            "author": "",
            "category": "",
            "content": "Наверняка, пару бесхозных магнитов можно найти в каждом доме. Если их нет – есть как минимум 10 поводов для покупки. Будьте осторожны. Мемомагнетика (коллекционирование магнитов) затягивает. Уроженка Хендерсона (США) Луиза Гринфарб располагает коллекцией в 40 тысяч экземпляров и не намерена останавливаться. Чтобы сделать жизнь удобнее, понадобится лишь несколько магнитов.1. Тюнинг отверткиОбыкновенную отвертку можно протюнинговать, прикрепив к ее металлической части небольшой магнит. Теперь гвозди и саморезы будут сами держаться на острие. Преимущества намагниченной отвертки вы наверняка оцените.2. Шуруповерт с функцией держателяАналогичным образом можно поступить с шуруповертом, оборудовав на нем держатель. Приклеенный на термоклей плоский и длинный магнит удержит некоторое количество шурупов, что значительно упростит и ускорит работу.3. Держатель для проводовС помощью пружинки из автоматической ручки обработайте основания проводов. К боковой стороне стола прикрепите на термоклей магниты. Удобная конструкция для крепления проводов готова.4. Гвозди на выданьеМагнит размером с монетку, брошенный в карман, позволит закрепить на внешней стороне одежды небольшие гвозди. Теперь при работе с молотком гвозди всегда будут при вас. А как удобно их доставать!5. Гвозди – вбиты, пальцы – целыНужно вбить гвоздь, а страх повредить пальцы лишает мужества? Воспользуйтесь магнитом, который придержит строптивый гвоздь на месте, пока молоток будет заниматься своим убойным делом.6. В шеренгу становись!С помощью магнитов можно упорядочить пространство на балконе или в мастерской. Приклеенные к стене магниты – прекрасный держатель для инструментов и других металлических предметов.7. Оптимизация кухонного пространстваКогда специям и другим баночкам-скляночкам на кухне не находится места, выручат магниты. Прикрепив их под полкой или на нижней части навесного шкафчика, можно удобно вешать емкости с металлическими крышками.8. Магнит притягивает деньгиМагнит притягивает деньги. Причем буквально. Если вы рассыпали на пол монеты (гвозди и другие металлические предметы), собрать их с помощью магнита не составит труда.9. Ручка на видном местеРучка под рукой? «Этого не бывает», – угрюмо скажете вы. Да, но с нашим лайфхаком ручка всегда будет лежать на видном месте. Открутите ручку, отрежьте небольшой кусочек стержня, а на его место вставьте магнит. Закрутите ручку. Повесьте на холодильник и удивляйтесь: «Почему я не делал этого раньше?».10. Магнитный держатель для ключейЕсли каждый раз, выходя из дома, вы не можете найти свои ключи, лайфхак – для вас. Приклейте у входа магнит. Теперь, опаздывая на встречу, вы не будете тратить драгоценное время на поиск ключей. Они – на месте. Пользу такой настенной ключницы оценит каждый деловой человек.",
        "url": "/blog/design/2018-01-01-10-sposobov-primeneniya-magnitov-v-bytu.html"
    }
    ,
    
    "blog-it-news-2018-01-01-jonsbo-gotovit-beluyu-versiyu-processornogo-kulera-html": {
        "title": "Jonsbo готовит белую версию процессорного кулера CR-301",
            "author": "",
            "category": "",
            "content": "Компания Jonsbo сообщила о намерении выпустить процессорный кулер CR-301 White Edition. По сути это вариация на тему представленной в декабре модели CR-301, отличающаяся от нее лишь цветовым оформлением. Как следует из названия, для окраски элементов CR-301 White Edition выбран белый цвет.Как и базовая модель, новинка имеет нестандартную компоновку с двумя расположенными горизонтально секциями радиатора разного размера. Ребра радиатора изготовлены из алюминия.В конструкции применены шесть С-образных 6-мм медных тепловых трубок, окрашенных в белый цвет. Четыре из них обеспечивают отвод тепла от пластины-основания к верхней (большей по размеру) секции радиатора, а еще две — к нижней. С целью повышения эффективности ребра последней соединены непосредственно с основанием.Кулер оборудован двумя управляемыми 120-мм вентиляторами, которые расположены горизонтально. Один из них установлен между секциями радиатора, второй — сверху. Управление частотой вращения в пределах от 600 до 1600 об./мин осуществляется методом широтно-импульсной модуляции (ШИМ, PWM). Заявленный в спецификации уровень шума варьируется от 18 до 25 дБ (А) в зависимости от скорости. Оба вентилятора оборудованы настраиваемой подсветкой.В комплект поставки входят приспособления для установки кулера на процессоры Intel с разъемами LGA775, LGA1150, LGA1151, LGA1155 и LGA1156, а также на процессоры AMD с разъемами FM1, FM2, FM2+, AM2, AM2+, AM3, AM3+ и AM4.Согласно спецификации, данная модель способна обеспечить эффективное охлаждение процессоров с показателем максимальной рассеиваемой тепловой мощности (TDP) до 135 Вт. Размеры кулера — 128×138×135 мм; вес — 890 г.",
        "url": "/blog/it-news/2018-01-01-jonsbo-gotovit-beluyu-versiyu-processornogo-kulera.html"
    }
    ,
    
    "blog-it-news-2018-01-01-huawei-anonsirovala-noutbuk-matebook-d-html": {
        "title": "Huawei анонсировала ноутбук MateBook D",
            "author": "",
            "category": "",
            "content": "Компания Huawei анонсировала портативный ПК Matebook D в варианте 2018 года. Он выполнен в металлическом корпусе, толщина которого в сложенном состоянии составляет всего 16,9 мм, а дизайн практически в неизменном виде унаследован от предыдущей версии.Экран встроенного дисплея имеет размер 15,6 дюйма по диагонали и разрешение Full HD (1920×1080 пикселов). Ноутбук оборудован клавиатурой без цифровой секции и большой сенсорной панелью.Модель Huawei MateBook D (2018) будет выпущена в нескольких конфигурациях. Все они оснащены процессорами Intel Core восьмого поколения и дискретными графическими адаптерами NVIDIA MX150. В наиболее доступной по цене модификации установлены процессор Intel Core i5-8250U, 8 Гбайт ОЗУ и твердотельный накопитель емкостью 256 Гбайт. Средняя конфигурация включает такой же процессор, но отличается составом дисковой подсистемы: здесь установлены 2,5-дюймовый жесткий диск объемом 1 Тбайт и твердотельный накопитель емкостью 128 Гбайт. И, наконец, топовый вариант Huawei MateBook D (2018) базируется на процессоре Intel Core i7-8550U.Во всех конфигурациях предусмотрены встроенный адаптер Wi-Fi, выход HDMI, а также два порта USB 3.0 и один USB 2.0.Энергоемкость штатной аккумуляторной батареи составляет 43,3 Вт•ч. Как утверждает производитель, полного заряда хватит примерно на 8,5 ч непрерывного воспроизведения видео или на 10 ч работы.",
        "url": "/blog/it-news/2018-01-01-huawei-anonsirovala-noutbuk-matebook-d.html"
    }
    
    
    };
</script>
<script src="js/scripts.min.js"></script>


							</div>
						</div>

					</article>

				</div>

				<div class="col-md-4">

<aside class="main-aside">

	<div class="aside-box">

<div class="latest-box">

	<div class="lb-header">Последние статьи:</div>

	<div class="lb-list">

		<div class="lb-item">
			<a href="blog/javascript/" class="lb-catname">JavaScript</a>
			<div class="lb-body">

				
				<a class="lb-item-header" href="/blog/javascript/2018-05-20-vvedenie-v-karrirovanie-v-javascript.html">Введение в каррирование в JavaScript</a>
				<div class="lb-footer">
					<div class="item-comments" title="Количество комментариев">
						<i class="fa fa-comment"></i><a class="item-comments-count" href="/blog/javascript/2018-05-20-vvedenie-v-karrirovanie-v-javascript.html#disqus_thread"></a>
						<span class="date">20/05/2018</span>
					</div>
				</div>
				

			</div>
		</div>

		<div class="lb-item">
			<a href="blog/it-news/" class="lb-catname">Новости IT</a>
			<div class="lb-body">

				
				<a class="lb-item-header" href="/blog/it-news/2018-01-20-hyperx-predator-ddr4-rgb-s-sinhronizaciej-podsvetki.html">HyperX Predator DDR4 RGB с синхронизацией подсветки через ИК</a>
				<div class="lb-footer">
					<div class="item-comments" title="Количество комментариев">
						<i class="fa fa-comment"></i><a class="item-comments-count" href="/blog/it-news/2018-01-20-hyperx-predator-ddr4-rgb-s-sinhronizaciej-podsvetki.html#disqus_thread"></a>
						<span class="date">20/01/2018</span>
					</div>
				</div>
				

			</div>
		</div>

		<div class="lb-item">
			<a href="blog/html-css/" class="lb-catname">HTML & CSS</a>
			<div class="lb-body">

				
				<a class="lb-item-header" href="/blog/html-css/2018-05-25-vvedenie-v-css-grid.html">Введение в CSS Grid</a>
				<div class="lb-footer">
					<div class="item-comments" title="Количество комментариев">
						<i class="fa fa-comment"></i><a class="item-comments-count" href="/blog/html-css/2018-05-25-vvedenie-v-css-grid.html#disqus_thread"></a>
						<span class="date">25/05/2018</span>
					</div>
				</div>
				

			</div>
		</div>

		<div class="lb-item">
			<a href="blog/design/" class="lb-catname">Дизайн</a>
			<div class="lb-body">

				
				<a class="lb-item-header" href="/blog/design/2018-01-20-10-udobnyh-reshenij-dlya-ispolzovaniya-plansheta.html">10 удобных решений, хитростей и приемов для использования планшета</a>
				<div class="lb-footer">
					<div class="item-comments" title="Количество комментариев">
						<i class="fa fa-comment"></i><a class="item-comments-count" href="/blog/design/2018-01-20-10-udobnyh-reshenij-dlya-ispolzovaniya-plansheta.html#disqus_thread"></a>
						<span class="date">20/01/2018</span>
					</div>
				</div>
				

			</div>
		</div>

		<div class="lb-item">
			<a href="blog/other/" class="lb-catname">Другое</a>
			<div class="lb-body">

				
				<a class="lb-item-header" href="/blog/other/2018-05-09-besplatnyy-sayt-na-github-pages-pri-pomoshchi-jekyll.html">Cайт на GitHub Pages при помощи Jekyll</a>
				<div class="lb-footer">
					<div class="item-comments" title="Количество комментариев">
						<i class="fa fa-comment"></i><a class="item-comments-count" href="/blog/other/2018-05-09-besplatnyy-sayt-na-github-pages-pri-pomoshchi-jekyll.html#disqus_thread"></a>
						<span class="date">09/05/2018</span>
					</div>
				</div>
				

			</div>
		</div>
		
	</div>

</div>

	</div>

	<div class="aside-box">
<div id="vk_groups"></div>
	</div>

</aside>

				</div>

			</div>
		</div>
	</div>

	<footer class="main-footer">
		<div class="contaiter">

			<nav class="main-menu footer-menu">
	<ul>
	<li><a href="blog/javascript/">JavaScript</a></li>
	<li><a href="blog/html-css/">Html&Css</a></li>
	<li><a href="blog/design/">Дизайн</a></li>
	<li><a href="blog/it-news/">Новости</a></li>
	<li><a href="blog/other/">Другое</a></li>
	<li><a href="projects/">Проекты</a></li>
</ul>
			</nav>

			<nav class="soc">
				<ul>
	<li><a href="#"><i class="fa fa-vk"></i></a></li> <li><a href="#"><i class="fa fa-facebook"></i></a></li> <li><a href="#"><i class="fa fa-odnoklassniki"></i></a></li> <li><a href="#"><i class="fa fa-instagram"></i></a></li> <li><a href="rss.xml"><i class="fa fa-rss"></i></a></li>
				</ul>
			</nav>

		</div>
	</footer>
	<footer class="bottom-footer">
		<div class="container text-center">
			<div class="footer-copy">2018 © <span class="logo-footer logo-litera">Frontendly.ru</span></div>
			<p>Копирование контента и размещение на других сайтах запрещено.</p>
		</div>
	</footer>

	<script src="js/scripts.min.js"></script>

	<script id="dsq-count-scr" src="//frontendly-ru.disqus.com/count.js" async></script>

	<!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->

	<!--<script type="text/javascript" src="//vk.com/js/api/openapi.js?152"></script>-->
	<!--<script type="text/javascript">-->
	<!--VK.Widgets.Group("vk_groups", {mode: 0, width: 'auto,', height: '300', color2: '202222', color3: '202222'}, you_id);-->
	<!--</script>-->

</body>
</html>
